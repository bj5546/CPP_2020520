//#include "stdafx.h"
#include "pthread.h"
#include "m_arith.h"
#ifdef DETECT_GPU//GPU
#include "yolo_detector.h"
#else//ncs
#include "NCS_detector.h"
#endif
#ifdef DETECT_PERSON_ATTRIBUTE//检测行人属性
#include "attribute_detect.h"
#endif
#ifdef DETECT_PLATE//检测车牌
#include "lpr/include/PlateRecognize.h"
#endif
using namespace std;
//////////////////////////////////////////////////////////////////////////////////////

#define	MAX_SPEEDDETECTOR_DOTS	768*576
#define MaxDotsInDetect 768*576
//#define FULL_COLS  					(720)
//#define FULL_ROWS  					(576)

clock_t current_time;
double timer;
//#define  SAVE_VIDEO 
#ifdef SAVE_VIDEO
cv::Mat img;
# define  SAVE_FRAMES  3000
cv::VideoWriter writer("VideoResult.avi", CV_FOURCC('X', 'V', 'I', 'D'), 15, Size(FULL_COLS, FULL_ROWS)); 
#endif
//char LABELS[][50] = {"background", "bus", "car", "truck", "bicycle", "motorbike", "person"};
//char LABELS[][50] = {"bus","car", "truck", "motorbike", "bicycle","person"};
char LABELS[][50] = {"bus","car", "truck", "motorbike", "bicycle", "person", "plate", "bottle", "cup",\
	"Reserve0", "Reserve1", "Reserve2", "Reserve3", "Reserve4", "Reserve5", "Reserve6", "Reserve7", "Reserve8", "Reserve9",\
    "js", "kw", "ps", "lf"};

int alg_mem_malloc(m_args *p)
{
	//printf("malloc.......\n");
	int ret = -1;
	int size;
	int i = 0;
	//输出内存分配

	//	ALGPARAMS *Params;
	p->p_outbuf = NULL;
	p->p_outbuf = (OUTBUF*) malloc(sizeof(OUTBUF));
	if (p->p_outbuf == NULL) {
		printf("alg malloc err\n");
	}
	memset(p->p_outbuf, 0, sizeof(OUTBUF));

	//参数配置内存分配
	p->pParams = NULL;
	p->pParams = (ALGPARAMS*) malloc(sizeof(ALGPARAMS));
	if (p->pParams == NULL) {
		printf("alg malloc err\n");
	}
	memset(p->pParams, 0, sizeof(ALGPARAMS));
	p->pParams->CurrQueueImage = NULL;

	p->pParams->CurrQueueImage = (Uint8*) malloc(
		DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX * 10 * sizeof(Uint8));
	if (p->pParams->CurrQueueImage == NULL) {
		printf("alg malloc err\n");
	}
	p->pParams->MaskEventImage = NULL;
	p->pParams->MaskEventImage = (Uint32*)malloc(
		DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX * sizeof(Uint32));
	if (p->pParams->CurrQueueImage == NULL || p->pParams->MaskEventImage == NULL) {
		printf("alg malloc err\n");
	}

	memset(p->pParams->CurrQueueImage, 0,
		DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX * 10 * sizeof(Uint8));
	memset(p->pParams->MaskEventImage, 0,
		DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX  * sizeof(Uint32));

	//配置内存分配
	p->pCfgs = NULL;
	p->pCfgs = (ALGCFGS*) malloc(sizeof(ALGCFGS));
	if (p->pCfgs == NULL) {
		printf("alg malloc err\n");
	}else{
		printf("alg malloc ok \n");
	}

	memset(p->pCfgs, 0, sizeof(ALGCFGS));

#ifdef DETECT_GPU
	p->pCfgs->net_params = (NET_PARAMS *) malloc(sizeof(NET_PARAMS));
	p->pCfgs->net_params->net = NULL;
	p->pCfgs->net_params->names = NULL;
#else//NCS
	p->pCfgs->NCS_ID = get_ncs_id();
#endif
#ifdef DETECT_PERSON_ATTRIBUTE//加载行人属性识别网络
	attri_init();
#endif
#ifdef DETECT_PLATE//加载车牌识别网络
	p->pCfgs->plate_flag = LoadPlateNet();
	if(p->pCfgs->plate_flag < 0)
		printf("no load plate recognize net\n");
#endif
	//printf("(pCfgs malloc %x,%x\n",p->pCfgs,pthread_self());fflush(NULL);
	//printf("(pCfgs malloc %x\n",p->pCfgs->CameraCfg);
	return 0;
}

int alg_mem_free(m_args *arg_arg)
{
	//printf("free.......\n");
#ifdef DETECT_GPU
	if(arg_arg->pCfgs->net_params)
	{
		free_yolo_network_params(arg_arg->pCfgs->net_params, arg_arg->pCfgs->net_params->handle_index);
		free(arg_arg->pCfgs->net_params);
		arg_arg->pCfgs->net_params = NULL;
	}
#else
	if(arg_arg->pCfgs->NCS_ID >= 0)
	{
		free_ncs_id(arg_arg->pCfgs->NCS_ID);//设置此计算棒不能运行
	}
	//py_free();
#endif
#ifdef DETECT_PLATE//释放车牌识别网络
	if(arg_arg->pCfgs->plate_flag >= 0)
	{
		FreePlateNet(arg_arg->pCfgs->plate_flag);
	}
#endif
		free(arg_arg->pCfgs);
		arg_arg->pCfgs = NULL;

	if ( arg_arg->pParams) {
		if (arg_arg->pParams->CurrQueueImage) {
			free(arg_arg->pParams->CurrQueueImage);
			arg_arg->pParams->CurrQueueImage = NULL;
		}
		if((arg_arg)->pParams->MaskEventImage) {
			free((arg_arg)->pParams->MaskEventImage);
			(arg_arg)->pParams->MaskEventImage = NULL;
		}

		free(arg_arg->pParams);
		arg_arg->pParams = NULL;
	}
	if (arg_arg->p_outbuf) {
		free(arg_arg->p_outbuf);
		arg_arg->p_outbuf = NULL;
	}
	return 0;
}

#define max(a,b) (((a)>(b)) ? (a):(b))
#define min(a,b) (((a)>(b)) ? (b):(a))

//设置pParams->MaskDetectImage为行人检测区域
bool MaskDetectImage(ALGCFGS *pCfgs, ALGPARAMS *pParams, int imgW, int imgH)
{
	Int32	i, j, k;
	CPoint	ptCorner[4];
	Uint8* p;
	CPoint pt;
	//标记检测区域,如果图像大小大于640*480，resize到640*480
	memset(pParams->MaskDetectImage, 0, pCfgs->m_iWidth * pCfgs->m_iHeight);
	//传入行人检测区域
	pCfgs->uDetectRegionNum = pCfgs->DownDetectCfg.PersonDetectArea.num;
	for(i = 0; i < pCfgs->uDetectRegionNum; i++)	
	{
		ptCorner[0].x = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[0].x;
		ptCorner[0].y = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[0].y;
		ptCorner[1].x = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[1].x;
		ptCorner[1].y = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[1].y;
		ptCorner[2].x = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[2].x;
		ptCorner[2].y = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[2].y;
		ptCorner[3].x = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[3].x;
		ptCorner[3].y = pCfgs->DownDetectCfg.PersonDetectArea.area[i].realcoordinate[3].y;
		printf("person region = %d,[%d,%d,%d,%d,%d,%d,%d,%d]\n",i,ptCorner[0].x,ptCorner[0].y,ptCorner[1].x,ptCorner[1].y,ptCorner[2].x,ptCorner[2].y,ptCorner[3].x,ptCorner[3].y);

		//按照顺时针方向矫正4点顺序
		CorrectRegionPoint(ptCorner);

		//将坐标限制在[0 pCfgs->m_iWidth - 1]和[0 pCfgs->m_iHeight-1]
		for(j = 0; j < 4; j++)
		{
			ptCorner[j].x = ptCorner[j].x * pCfgs->m_iWidth / imgW;
			ptCorner[j].y = ptCorner[j].y * pCfgs->m_iHeight / imgH;
		}

		//对pParams->MaskDetectImage进行初始化代表不同的检测区域
		for(j = 0; j < pCfgs->m_iHeight; j++)
		{
			p = pParams->MaskDetectImage + j * pCfgs->m_iWidth;
			for(k = 0; k < pCfgs->m_iWidth; k++)
			{
				pt.x = k;
				pt.y = j;
				if(isPointInRect(pt, ptCorner[3], ptCorner[0], ptCorner[1], ptCorner[2]))
				{
					p[k] =  i + 1;
					//p[k] = 255;
				}
			}
		}
	}
	/*IplImage* mask = cvCreateImage(cvSize(pCfgs->m_iWidth, pCfgs->m_iHeight), IPL_DEPTH_8U, 1);
	memcpy(mask->imageData, pParams->MaskDetectImage, pCfgs->m_iWidth * pCfgs->m_iHeight);
	cvSaveImage("mask.jpg", mask, 0);
	cvReleaseImage(&mask);*/

	return	TRUE;

}

//设置pParams->MaskLaneImage为车道区域
bool MaskLaneImage(ALGCFGS *pCfgs, ALGPARAMS *pParams, int imgW, int imgH)
{
	Int32	i, j, k;
	CPoint	ptCorner[4];
	Uint8* p;
	CPoint pt;
	//标记检测区域,如果图像大小大于640*480，resize到640*480
	memset(pParams->MaskLaneImage, 0, pCfgs->m_iWidth * pCfgs->m_iHeight);
	//车道区域
	for(i = 0; i < pCfgs->LaneAmount; i++)	
	{
		memcpy( (void*)ptCorner, (void*)pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion, 4 * sizeof(CPoint) );
		printf("lane region = %d,[%d,%d,%d,%d,%d,%d,%d,%d]\n", i, ptCorner[0].x,ptCorner[0].y, ptCorner[1].x, ptCorner[1].y, ptCorner[2].x, ptCorner[2].y,ptCorner[3].x,ptCorner[3].y);
		//按照顺时针方向矫正4点顺序
		CorrectRegionPoint(ptCorner);
		//车道坐标不在检测区域内，返回
		/*for(j = 0; j < 4; j++)
		{
			if(ptCorner[j].x < 0 || ptCorner[j].x > imgW || ptCorner[j].y < 0 || ptCorner[j].y > imgH)
			{
				printf("detect lane region Point err\n");
				return FALSE;
			}		
		}*/
		//将坐标限制在[0 pCfgs->m_iWidth - 1]和[0 pCfgs->m_iHeight-1]
		for(j = 0; j < 4; j++)
		{
			ptCorner[j].x = ptCorner[j].x * pCfgs->m_iWidth / imgW;
			ptCorner[j].y = ptCorner[j].y * pCfgs->m_iHeight / imgH;
		}
		//对pParams->MaskLaneImage进行初始化代表不同的车道区域
		for(j = 0; j < pCfgs->m_iHeight; j++)
		{
			p = pParams->MaskLaneImage + j * pCfgs->m_iWidth;
			for(k = 0; k < pCfgs->m_iWidth; k++)
			{
				pt.x = k;
				pt.y = j;
				if(isPointInRect(pt, ptCorner[3], ptCorner[0], ptCorner[1], ptCorner[2]))
				{
					p[k] = i + 1;
				}
			}
		}
	}
	/*IplImage* mask = cvCreateImage(cvSize(pCfgs->m_iWidth, pCfgs->m_iHeight), IPL_DEPTH_8U, 1);
	memcpy(mask->imageData, pParams->MaskLaneImage, pCfgs->m_iWidth * pCfgs->m_iHeight);
	cvSaveImage("masklane.jpg", mask, 0);
	cvReleaseImage(&mask);*/

	return	TRUE;

}
//对图像进行标定
void get_calibration_data(ALGCFGS *pCfgs, int imgW, int imgH)
{
	int i = 0, j = 0, k = 0;
	int min_value = 1000;
	int idx = 0;
	CPoint pt1[2];
	//图像标定
	//if((pCfgs->calibration_point[2][1] > pCfgs->calibration_point[0][1]) && (pCfgs->calibration_point[3][1] > pCfgs->calibration_point[1][1]))
	camera_calibration(pCfgs->base_line, pCfgs->base_length, pCfgs->calibration_point, pCfgs->near_point_length, pCfgs->LaneAmount, pCfgs, imgW, imgH);
	//得到远近线圈的实际长度
	for(i = 0; i < pCfgs->LaneAmount; i++)
	{
		pt1[0].y = (pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0].y + pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1].y) / 2;
		pt1[1].y = (pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[2].y + pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[3].y) / 2;
		pCfgs->uActualTailLength[i] = (abs(pCfgs->actual_distance[i][pt1[0].y] - pCfgs->actual_distance[i][pt1[1].y]) + 0.5);
		pt1[0].y = (pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[0].y + pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[1].y) / 2;
		pt1[1].y = (pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2].y + pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3].y) / 2;
		pCfgs->uActualDetectLength[i] = (abs(pCfgs->actual_distance[i][pt1[0].y] - pCfgs->actual_distance[i][pt1[1].y]) + 0.5);
		printf("actual length = [%d,%d]\n",pCfgs->uActualTailLength[i], pCfgs->uActualDetectLength[i]);
	}
	printf("coil actual length = %d,%d\n",pCfgs->uActualTailLength[0], pCfgs->uActualDetectLength[1]);
	//得到刻度线点
	for(i = 0; i < 20; i++)
	{
		pCfgs->degreepointY[i][0] = 0;
		pCfgs->degreepointY[i][1] = 0;
	}
	j = ((int)(pCfgs->near_point_length + 9) / 10 + 1) * 10;
	k = 0;
	for(i = imgH - 1; i >= 0; i--)
	{
		if(abs(pCfgs->actual_degree_length[i] - j) < min_value)
		{
			min_value = abs(pCfgs->actual_degree_length[i] - j);
			idx = i;
		}
		if((int)(pCfgs->actual_degree_length[i] + 0.5) == j)
		{
			pCfgs->degreepointY[k][0] = idx;
			pCfgs->degreepointY[k][1] = j;
			//printf("degree_y=%d,len=%d\n", pCfgs->degreepointY[k][0], pCfgs->degreepointY[k][1]);
			min_value = 1000;
			j = j + 10;
			k++;


		}
		if(k == 20)
		{
			break;
		} 
	}
	//x方向刻度线
	k = 0;
	j = 5;
	for(i = 0; i < 10; i++)
	{
		pCfgs->degreepointX[i][0] = 0;
		pCfgs->degreepointX[i][1] = 0;
	}
	for(i = imgW - 1; i >= 0; i--)
	{
		if((int)(pCfgs->image_actual[imgH - 1][i][0] + 0.5) == j)
		{
			pCfgs->degreepointX[k][0] = i;
			pCfgs->degreepointX[k][1] = j;
			j = j + 5;
			k++;


		}
		if(k == 10)
		{
			break;
		} 
	}
	//pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uDegreeLength=pCfgs->actual_degree_length;

}
//初始化参数
bool ArithInit(Uint16 ChNum, CFGINFOHEADER *pCfgHeader, SPEEDCFGSEG *pDetectCfgSeg, ALGCFGS *pCfgs, ALGPARAMS *pParams, int gpu_index)
{
	int i = 0;
	bool bInit = FALSE;
	bInit = CfgStructParse(ChNum, pCfgHeader, pDetectCfgSeg, pCfgs, pParams);//加载参数，参数初始化
#ifdef DETECT_GPU
	//加载权重、类名、检测阈值
	if(pCfgs->net_params->net == NULL)
	{
		LoadNetParams(pCfgs->net_params, gpu_index);
	}
#ifdef DETECT_PERSON_ATTRIBUTE
#ifndef USE_PYTHON
	//加载行人属性网络
	LoadAttriNet(gpu_index);
	printf("load attri net\n");
#endif
#endif
#endif
	pCfgs->classes = sizeof(LABELS)/sizeof(LABELS[0]);//检测类别数
	//加载类别名
	for( i = 0; i < pCfgs->classes; i++)
	{
		strcpy(pCfgs->detClasses[i].names, LABELS[i]);
	}
   //交通事件初始化
   CfgEventRegion(pDetectCfgSeg->uSegData->EventDetectArea, pCfgs, pParams);
   //行人属性初始化
#ifdef DETECT_PERSON_ATTRIBUTE
   HumanAttributeInit(pCfgs);
   BicycleAttributeInit(pCfgs);
#endif
	return bInit;
}

//配置参数
bool CfgStructParse(Uint16 ChNum, CFGINFOHEADER *pCfgHeader, SPEEDCFGSEG *pDetectCfgSeg, ALGCFGS *pCfgs, ALGPARAMS *pParams)//,CPoint m_ptend[],CPoint LineUp[]
{
	Int32	i, j, k, idx;
	float min_value = 1000;
	ZENITH_SPEEDDETECTOR 		*pDownSpeedDetect = NULL;
	CPoint	ptFlowCorner[4];//流量区域坐标点
	CPoint	ptMiddleCoil[4];//占有线圈坐标点 
	CPoint	ptFrontCoil[4];//占位线圈坐标点
	CPoint  ptLaneRegion[4];//车道区域坐标点
	CPoint  pt1[MAX_REGION_NUM][2];

	pDownSpeedDetect = (ZENITH_SPEEDDETECTOR*)pDetectCfgSeg->uSegData;

	//加载参数
	pCfgs->LaneAmount = pDownSpeedDetect->uLaneTotalNum;
	pCfgs->bAuto = pDownSpeedDetect->uEnvironment; //TRUE;

	//分配内存
	pParams->PreQueueImage = (Uint8 *)pParams->CurrQueueImage + DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX;//前一帧图像
	pParams->PrePreQueueImage = (Uint8 *)pParams->CurrQueueImage + DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX * 2;//前两帧图像
	pParams->PrePrePreQueueImage = (Uint8 *)pParams->CurrQueueImage + DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX * 3;//保存中间结果图像
	pParams->MaskLaneImage = (Uint8 *)pParams->CurrQueueImage + DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX * 4;//车道掩模图像
    pParams->MaskDetectImage = (Uint8 *)pParams->CurrQueueImage + DETECTRECT_WIDTH_MAX * DETECTRECT_HEIGHT_MAX * 5;//行人检测区域图像
	////////////////////////////////////////////////////////////////
	//得到每个车道参数，并对图像区域进行矫正
	for(i=0; i<pCfgs->LaneAmount; i++)
	{
		memcpy( (void*)ptFlowCorner, (void*)pDownSpeedDetect->SpeedEachLane[i].RearCoil, 4 * sizeof(CPoint));
		memcpy( (void*)ptMiddleCoil, (void*)pDownSpeedDetect->SpeedEachLane[i].MiddleCoil, 4 * sizeof(CPoint));
		memcpy( (void*)ptFrontCoil, (void*)pDownSpeedDetect->SpeedEachLane[i].FrontCoil, 4 * sizeof(CPoint));
		memcpy( (void*)ptLaneRegion, (void*)pDownSpeedDetect->SpeedEachLane[i].LaneRegion, 4 * sizeof(CPoint));

		//判断坐标是否越界
		for(j = 0; j < 4; j++)
		{
			if(ptLaneRegion[j].x < 0 || ptLaneRegion[j].x >= MAX_IMAGE_WIDTH || ptLaneRegion[j].y < 0 || ptLaneRegion[j].y >= MAX_IMAGE_HEIGHT)
			{
				printf("Lane Point err \n");
				//return FALSE;
			}
			if(ptFlowCorner[j].x < 0 || ptFlowCorner[j].x >= MAX_IMAGE_WIDTH || ptFlowCorner[j].y < 0 || ptFlowCorner[j].y >= MAX_IMAGE_HEIGHT)
			{
				printf("flow Point err \n");
				//return FALSE;
			}
			if(ptMiddleCoil[j].x < 0 || ptMiddleCoil[j].x >= MAX_IMAGE_WIDTH || ptMiddleCoil[j].y < 0 || ptMiddleCoil[j].y >= MAX_IMAGE_HEIGHT)
			{
				printf("Far Point err \n");
				//return FALSE;
			}
			if(ptFrontCoil[j].x < 0 || ptFrontCoil[j].x >= MAX_IMAGE_WIDTH || ptFrontCoil[j].y < 0 || ptFrontCoil[j].y >= MAX_IMAGE_HEIGHT)
			{
				printf("Far Point err \n");
				//return FALSE;
			}
		}

		CorrectRegionPoint(ptFlowCorner);//矫正流量区域
		CorrectRegionPoint(ptMiddleCoil);//矫正占有区域
		CorrectRegionPoint(ptFrontCoil);//矫正占位区域
		CorrectRegionPoint(ptLaneRegion);//矫正车道区域
		
			
		memcpy( (void*)pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil, (void*)ptFlowCorner, 4 * sizeof(CPoint) );
		memcpy( (void*)pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil, (void*)ptMiddleCoil, 4 * sizeof(CPoint) );
		memcpy( (void*)pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil, (void*)ptFrontCoil, 4 * sizeof(CPoint) );
		memcpy( (void*)pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion, (void*)ptLaneRegion, 4 * sizeof(CPoint) );

		printf("lane region = [%d,%d,%d,%d,%d,%d,%d,%d]\n",pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[0].x, pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[0].y, pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[1].x, pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[1].y, pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[2].x, pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[2].y, pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[3].x, pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[3].y);
		printf("front region = [%d,%d,%d,%d,%d,%d,%d,%d]\n",pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[0].x, pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[0].y, pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[1].x, pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[1].y, pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[2].x, pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[2].y, pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[3].x, pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[3].y);
		printf("middle region = [%d,%d,%d,%d,%d,%d,%d,%d]\n",pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0].x, pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0].y, pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1].x, pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1].y, pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[2].x, pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[2].y, pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[3].x, pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[3].y);
		printf("rear region = [%d,%d,%d,%d,%d,%d,%d,%d]\n",pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[0].x, pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[0].y, pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[1].x, pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[1].y, pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2].x, pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2].y, pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3].x, pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3].y);

	}
	
	//得到工作模式 白天或晚上
	if(pCfgs->bAuto == 2)
	{
		pCfgs->bNight = TRUE;
	}
	else
	{	
		pCfgs->bNight = FALSE;
	}

	//得到4个标定点和基准线端点
	for(i = 0; i < 4; i++)
	{
		pCfgs->calibration_point[i][0] = pDownSpeedDetect->ptimage[i].x;
		pCfgs->calibration_point[i][1] = pDownSpeedDetect->ptimage[i].y;

	}
	for(i = 4; i < 8; i++)
	{
		pCfgs->base_line[i - 4][0] = pDownSpeedDetect->ptimage[i].x;
		pCfgs->base_line[i - 4][1] = pDownSpeedDetect->ptimage[i].y;
	}
	pCfgs->base_length[0] = pDownSpeedDetect->base_length[0];//垂直基准线长
	pCfgs->base_length[1] = pDownSpeedDetect->base_length[1];//水平基准线长
	pCfgs->near_point_length = pDownSpeedDetect->near_point_length;
	printf("calibration point = [%d,%d],[%d,%d],[%d,%d],[%d,%d]\n",pCfgs->calibration_point[0][0], pCfgs->calibration_point[0][1], pCfgs->calibration_point[1][0], pCfgs->calibration_point[1][1], pCfgs->calibration_point[2][0], pCfgs->calibration_point[2][1], pCfgs->calibration_point[3][0], pCfgs->calibration_point[3][1]);
	printf("base line = [%d,%d],[%d,%d],[%d,%d],[%d,%d]\n",pCfgs->base_line[0][0],pCfgs->base_line[0][1], pCfgs->base_line[1][0], pCfgs->base_line[1][1], pCfgs->base_line[2][0], pCfgs->base_line[2][1], pCfgs->base_line[3][0], pCfgs->base_line[3][1]);
    printf("base length = %f,%f,near_point_length =%f\n",pCfgs->base_length[0],pCfgs->base_length[1], pCfgs->near_point_length);

	//加载行人检测参数
	pCfgs->DownDetectCfg.PersonDetectArea = pDownSpeedDetect->PersonDetectArea;//行人检测区域
	pCfgs->uDetectRegionNum = pCfgs->DownDetectCfg.PersonDetectArea.num;//行人区域数
	//行人检测线
	for(i = 0; i < pCfgs->uDetectRegionNum; i++)
	{
		pt1[i][0].x = pDownSpeedDetect->PersonDetectArea.area[i].detectline[0].x;
		pt1[i][0].y = pDownSpeedDetect->PersonDetectArea.area[i].detectline[0].y;
		pt1[i][1].x = pDownSpeedDetect->PersonDetectArea.area[i].detectline[1].x;
		pt1[i][1].y = pDownSpeedDetect->PersonDetectArea.area[i].detectline[1].y;
		memset(pCfgs->uPersonDirNum[i], 0, MAX_DIRECTION_NUM * sizeof(Uint16));//行人方向数
	}
	//求行人检测线的斜率和截距
	SetLine(pCfgs, pt1);
	pCfgs->person_id = 1;//行人目标ID
	pCfgs->objPerson_size = 0;//行人目标数
	memset(pCfgs->uRegionPersonNum, 0, MAX_REGION_NUM * sizeof(Uint16));//区域行人数
 
	pCfgs->gThisFrameTime = 0; 
	////////////////////////////////////////////////////detect params初始化参数
	pCfgs->target_id = 1;
	pCfgs->targets_size = 0;
	memset(pCfgs->targets, 0, MAX_TARGET_NUM * sizeof(CTarget));
	memset(pCfgs->detClasses, 0, MAX_CLASSES * sizeof(CDetBox));
	for( i = 0; i < MAX_LANE; i++)
	{
		memset(pCfgs->detBoxes, 0 , MAX_LANE_TARGET_NUM * sizeof(Rect));
	}
	memset(pCfgs->detNum, 0, MAX_LANE * sizeof(Uint16));
	//memset(pCfgs->uStatPersonNum, 0, 4 * sizeof(Uint16));
	memset(pCfgs->detTargets, 0, MAX_TARGET_NUM * sizeof(CTarget));
	pCfgs->detTarget_id = 1;
	pCfgs->detTargets_size = 0;

	for(i = 0; i < MAX_LANE; i++)
	{
		pCfgs->uDetectVehicleSum[i] = 0;
		memset(pCfgs->uStatVehicleSum[i], 0, 4 * sizeof(Uint16));
		memset(pCfgs->uStatQuePos[i], 0, 6 * sizeof(Uint16));
		pCfgs->uDetectVehicleFrameNum[i] = 0;
		pCfgs->uRearIntervalNum[i] = 0;//后线圈两目标之间间隔
		pCfgs->existFrameNum[i][0] = 0;
		pCfgs->existFrameNum[i][1] = 0;
	}
	pCfgs->bMaskDetectImage = FALSE;//未设置检测区域掩模图像
	pCfgs->bMaskLaneImage = FALSE;//未设置车道掩模图像
	pCfgs->bCalibrationImage = FALSE;//未进行标定
	return	TRUE;

}

inline Uint16 CalTargetSpeed(CTarget target, int laneID, ALGCFGS *pCfgs)//计算目标实际速度
{
	float uVehicleSpeed = 0;
	int pos1 = target.trajectory[0].y;
	//int pos1 = target.trajectory[target.trajectory_id[idx]].y;
	int pos2 = target.box.y + target.box.height / 2;
	float len = pCfgs->actual_distance[laneID][pos2] - pCfgs->actual_distance[laneID][pos1];
	len = (len > 0)? len : -1 * len;
	uVehicleSpeed = len * 3.6 / (target.end_time - target.start_time + 1e-6);
	//printf("[%d,%d,%d],len = %f, t = %f,speed = %f,[%f,%f]\n", target.continue_num, pos1, pos2, len, target.end_time - target.start_time, uVehicleSpeed,target.start_time,target.end_time);
/*#ifdef SAVE_VIDEO
	char str[10];
	sprintf(str, "speed:%d", (int)uVehicleSpeed);
	putText(img, str, Point(target.box.x + 50,max(0,target.box.y - 10)), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(255, 255,0 ), 2);
#endif*/
	if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[laneID].SpeedDetectInfo1.uVehicleQueueLength)
		uVehicleSpeed = (uVehicleSpeed > 15)? 15 : uVehicleSpeed;
	else
		uVehicleSpeed = (uVehicleSpeed > 60)? 60 : uVehicleSpeed;
	if(uVehicleSpeed <= 0)
		uVehicleSpeed = rand() % 5 + 1;
	return (Uint16)uVehicleSpeed;
}
inline Uint16 CalTargetLength(CTarget target, int laneID, ALGCFGS *pCfgs)//计算目标实际长度
{
	int pos1 = target.box.y;
	int pos2 = target.box.y + target.box.height ;
	float len = pCfgs->actual_distance[laneID][pos2] - pCfgs->actual_distance[laneID][pos1];
	len = (len > 0)? len : -1 * len;
	if(strcmp(target.names, "car") == 0)
	{
		len = (len < 3)? 3 : len;
		len = (len > 6)? 6 : len;
	}
	else if(strcmp(target.names, "truck") == 0)
	{
		len = (len < 6)? 6 : len;
		len = (len > 13)? 13 : len;
	}
	else
	{
		len = (len < 9)? 9 : len;
		len = (len > 15)? 15 : len;
	}
	return (Uint16)len;
}
//车辆进入线圈，设置参数
void obj_in_region(ALGCFGS *pCfgs, int LaneID, int idx)//0为流量线圈，1为后线圈
{
	pCfgs->headtime[LaneID] = pCfgs->currTime - pCfgs->jgtime[LaneID][idx];
	pCfgs->jgtime[LaneID][idx] = pCfgs->currTime;//用于计算头间距
	pCfgs->headtime[LaneID] = (pCfgs->headtime[LaneID] < 0)? 0 : pCfgs->headtime[LaneID];
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].uVehicleHeadtime = pCfgs->headtime[LaneID];//车头时距
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].calarflag = 1;//车在线圈内
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].DetectInSum++;
}
//车辆离开线圈,连续车辆时，前一车辆不删除目标但是出车，将calarflag设为2
void obj_out_region(ALGCFGS *pCfgs, int LaneID, CTarget* target, int idx)//0为流量线圈，1为后线圈
{
	if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].calarflag == 1)//车出线圈时，calarflag设置为2
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].calarflag = 2;
	if(target->cal_speed == FALSE)//未计算速度，计算车型、车速、车长
	{
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].DetectOutSum++;
		//pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].uVehicleType = target.class_id + 1;
		//clock_t end_time = clock(); 
		//target.end_time = (float)end_time / CLOCKS_PER_SEC;
		target->end_time = pCfgs->currTime;
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].uVehicleSpeed  = CalTargetSpeed(*target, LaneID, pCfgs);
		target->cal_speed = TRUE;
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.CoilAttribute[idx].uVehicleLength  = CalTargetLength(*target, LaneID, pCfgs);

	}
}

void ProcessDetectBox(ALGCFGS* pCfgs, int* result, int nboxes)//对检测框进行处理
{
	int i = 0, j = 0;
	int classes_num[MAX_CLASSES] = { 0 };
	int class_id = 0;
	memset(pCfgs->detClasses, 0, MAX_CLASSES * sizeof(CDetBox));//初始化检测框
	memset(classes_num, 0, MAX_CLASSES * sizeof(int));//初始化检测框数
	//把检测结果按照类别归类
	for(i = 0; i < nboxes; i++)
	{
		class_id = result[i * 6];
		//根据检测类别名找到LABLES对应类别
#ifdef DETECT_GPU
		for(j = 0; j < pCfgs->classes; j++)
		{
			if(strcmp(pCfgs->net_params->names[class_id], LABELS[j]) == 0)//找到对应的类别名
			{
				class_id = j;
				break;
			}
		}
		if(j == pCfgs->classes)//舍弃不需要的类别
			continue;
#endif	
		//去掉不符合条件的检测框
		if(result[i * 6 + 4] > 500 || result[i * 6 + 5] > 500 || result[i * 6 + 4] <= 0 || result[i * 6 + 5] <= 0)
			continue;
		pCfgs->detClasses[class_id].class_id = class_id;
		pCfgs->detClasses[class_id].prob[classes_num[class_id]] = result[i * 6 + 1];
		pCfgs->detClasses[class_id].box[classes_num[class_id]].x = result[i * 6 + 2];
		pCfgs->detClasses[class_id].box[classes_num[class_id]].y = result[i * 6 + 3];
		pCfgs->detClasses[class_id].box[classes_num[class_id]].width = result[i * 6 + 4];
		pCfgs->detClasses[class_id].box[classes_num[class_id]].height = result[i * 6 + 5];
		pCfgs->detClasses[class_id].lane_id[classes_num[class_id]] = -1;

		classes_num[class_id]++;
		pCfgs->detClasses[class_id].classes_num = classes_num[class_id];
		strcpy(pCfgs->detClasses[class_id].names, LABELS[class_id]);//类别名
	}
	//对检测框进行后处理
	post_process_box(pCfgs, 50);////对不同类别进行处理
	post_process_box_same(pCfgs, 50);//对相同类别进行处理
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////分析行人检测框
void ProcessPersonBox(ALGCFGS* pCfgs, ALGPARAMS *pParams, int width, int height)
{
	int i, j, k;
	int left = 0, right = 0, top = 0, bottom = 0;
	int dis1 = 0, dis2 = 0;
	int x = 0, y = 0;
	int x0 = 0, y0 = 0;
	float val1 = 0, val2 = 0;
	int nPersonNum = 0;
	Uint16 uRegionPersonNum[MAX_REGION_NUM] = { 0 };
	int match_object[MAX_TARGET_NUM] = { 0 };
	int match_rect[MAX_TARGET_NUM] = { 0 };
	int match_success = -1;
	bool isIntersect = FALSE;
	for(i = 0; i < pCfgs->uDetectRegionNum; i++)
	{
		memset(pCfgs->uPersonDirNum[i], 0, MAX_DIRECTION_NUM * sizeof(Uint16));//初始化区域方向数
	}
	for( i = 0; i < pCfgs->objPerson_size; i++)
	{
		pCfgs->objPerson[i].detected = FALSE;
	}
	//分析行人检测框
	for( i = 0; i < pCfgs->classes; i++)
	{
		if(strcmp(pCfgs->detClasses[i].names, "person") != 0 )
			continue;
		if(pCfgs->detClasses[i].classes_num)
		{
			match_object_rect(pCfgs->objPerson, pCfgs->objPerson_size, pCfgs->detClasses, i, match_object, match_rect, 5);
			for( j = 0; j < pCfgs->detClasses[i].classes_num; j++)
			{
				bool inRegion = FALSE;
				//判断行人是否在行人检测区域内
				for(k = 0; k < pCfgs->uDetectRegionNum; k++)
				{
					int isInRegion = RectInRegion(pParams->MaskDetectImage, pCfgs, width, height, pCfgs->detClasses[i].box[j], k);
					if(isInRegion > 10)//在检测区域内
					{
						inRegion = TRUE;//在区域内
						//pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum] = pCfgs->detClasses[i].box[j];
						/*pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].x = pCfgs->detClasses[i].box[j].x;
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].y = pCfgs->detClasses[i].box[j].y;
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].w = pCfgs->detClasses[i].box[j].width;
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].h = pCfgs->detClasses[i].box[j].height;
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].label = 0;
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].confidence = pCfgs->detClasses[i].prob[j];
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].id = 0;
						int pos_x = max(0, pCfgs->detClasses[i].box[j].x + pCfgs->detClasses[i].box[j].width / 2);
						pos_x = min(pos_x, width - 1);
						int pos_y =max(0, pCfgs->detClasses[i].box[j].y + pCfgs->detClasses[i].box[j].height / 2);
						pos_y = min(pos_y, height - 1);
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].distance[0] = pCfgs->image_actual[pos_y][pos_x][0];//目标与相机的水平距离
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].distance[1] = pCfgs->image_actual[pos_y][pos_x][1];//目标与相机的垂直距离
						pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].laneid = -1;//车道ID

#ifdef SAVE_VIDEO
						cv::rectangle(img, cv::Rect(pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].x, pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].y, pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].width, pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].height), cv::Scalar(0, 0,255), 1, 8, 0 );
#endif
						nPersonNum++;*/
						uRegionPersonNum[k]++;//相应区域行人数加1
					}
				}
				if(pCfgs->bDetPersonFlow == FALSE)//不检测行人方向流量
					continue;
				//判断行人是否与检测线相交
				left = pCfgs->detClasses[i].box[j].x;
				right = pCfgs->detClasses[i].box[j].x + pCfgs->detClasses[i].box[j].width;
				top = pCfgs->detClasses[i].box[j].y;
				bottom = pCfgs->detClasses[i].box[j].y + pCfgs->detClasses[i].box[j].height;
				/*CTarget* t;
				t = find_nearest_rect(pCfgs->detClasses[i].box[j], pCfgs->detClasses[i].class_id, pCfgs->objPerson, pCfgs->objPerson_size);
				if(t)//与已有目标匹配成功
				{
					t->box = pCfgs->detClasses[i].box[j];
					t->prob = pCfgs->detClasses[i].prob[j];
					t->class_id = pCfgs->detClasses[i].class_id;
					t->detected = TRUE;
				}
				else */
				match_success = -1;
				for( k = 0; k < pCfgs->objPerson_size; k++)
				{
					if(match_object[j] == k && match_rect[k] == j)//与目标匹配
					{
						match_success = 1;
						pCfgs->objPerson[k].box = pCfgs->detClasses[i].box[j];
						pCfgs->objPerson[k].prob = pCfgs->detClasses[i].prob[j];
						pCfgs->objPerson[k].class_id = pCfgs->detClasses[i].class_id;
						pCfgs->objPerson[k].detected = TRUE;
						break;
					}
				}
				if(match_success < 0)//未匹配
				{
					//与检测线相交加入目标链
					isIntersect = FALSE;
					for(k = 0; k < pCfgs->uDetectRegionNum; k++)//逐个与检测线判断，找到与检测线相交，并加入到目标
					{
						dis1 = min(pCfgs->detLineParm[k].detRight, right) - max(pCfgs->detLineParm[k].detLeft, left);
						//dis2 = min(pCfgs->detLineParm[k].detBottom, bottom) - max(pCfgs->detLineParm[k].detTop, top);
						val1 = pCfgs->detLineParm[k].k * left + pCfgs->detLineParm[k].b - top;
						val2 = pCfgs->detLineParm[k].k * right + pCfgs->detLineParm[k].b - bottom;
						//if(dis1 >= 0 && val1 * val2 <= 0 && pCfgs->objPerson_size < MAX_TARGET_NUM)//与检测线相交
						if(inRegion && pCfgs->objPerson_size < MAX_TARGET_NUM)//在检测区域内，加入到新目标
						{
							CTarget nt; 
							Initialize_target(&nt);
							nt.box = pCfgs->detClasses[i].box[j];
							nt.class_id = pCfgs->detClasses[i].class_id;
							nt.prob = pCfgs->detClasses[i].prob[j];
							nt.detected = TRUE;
							nt.target_id = pCfgs->person_id++;
							nt.region_idx = k;//行人与哪个检测线相交
							if(pCfgs->person_id > 5000)
								pCfgs->person_id = 1;
							strcpy(nt.names, pCfgs->detClasses[i].names);
							pCfgs->objPerson[pCfgs->objPerson_size] = nt;
							pCfgs->objPerson_size++;
							break;
						}
					}
				}
			}
		}
	}
	//分析行人目标
	for(i = 0; i < pCfgs->objPerson_size; i++)
	{
		int region_idx = pCfgs->objPerson[i].region_idx;
		//保存轨迹，轨迹数小于3000，直接保存，大于3000，去除旧的
		if(pCfgs->objPerson[i].trajectory_num < 3000)
		{

			pCfgs->objPerson[i].trajectory[pCfgs->objPerson[i].trajectory_num].x = pCfgs->objPerson[i].box.x + pCfgs->objPerson[i].box.width / 2;
			pCfgs->objPerson[i].trajectory[pCfgs->objPerson[i].trajectory_num].y = pCfgs->objPerson[i].box.y + pCfgs->objPerson[i].box.height / 2;
			pCfgs->objPerson[i].trajectory_num++;
		}
		else
		{
			for(j = 0; j < pCfgs->objPerson[i].trajectory_num - 1; j++)
			{
				pCfgs->objPerson[i].trajectory[j] = pCfgs->objPerson[i].trajectory[j + 1];
			}
			pCfgs->objPerson[i].trajectory[pCfgs->objPerson[i].trajectory_num - 1].x = pCfgs->objPerson[i].box.x + pCfgs->objPerson[i].box.width / 2;
			pCfgs->objPerson[i].trajectory[pCfgs->objPerson[i].trajectory_num - 1].y = pCfgs->objPerson[i].box.y + pCfgs->objPerson[i].box.height / 2;
		}

		//检测到，并更新速度
		if(pCfgs->objPerson[i].detected)
		{
			pCfgs->objPerson[i].lost_detected = 0;
            //get_speed(&pCfgs->objPerson[i]);
		}
		else//未检测到
		{
			pCfgs->objPerson[i].lost_detected++;
			pCfgs->objPerson[i].box.x += pCfgs->objPerson[i].vx;
			pCfgs->objPerson[i].box.y += pCfgs->objPerson[i].vy;
		}

		//判断是否计数
		x = pCfgs->objPerson[i].box.x + pCfgs->objPerson[i].box.width / 2 ;
		y = pCfgs->objPerson[i].box.y + pCfgs->objPerson[i].box.height / 2 ;
		x0 = pCfgs->objPerson[i].trajectory[0].x;
		y0 = pCfgs->objPerson[i].trajectory[0].y;
		if(pCfgs->objPerson[i].cal_flow == FALSE)
		{
			val1 = pCfgs->detLineParm[region_idx].k * x + pCfgs->detLineParm[region_idx].b - y;
			val2 = pCfgs->detLineParm[region_idx].k * x0 + pCfgs->detLineParm[region_idx].b - y0;
			if(val1 * val2 < 0)//从检测线一侧运动到另一侧
			{
				printf("get person obj\n");
				get_object_num(pCfgs, i, region_idx);
				pCfgs->objPerson[i].cal_flow = TRUE;
				//printf("%d,count 1\n",pCfgs->gThisFrameTime);
			}
		}
		left = pCfgs->objPerson[i].box.x;
		right = pCfgs->objPerson[i].box.x + pCfgs->objPerson[i].box.width;
		top = pCfgs->objPerson[i].box.y;
		bottom = pCfgs->objPerson[i].box.y + pCfgs->objPerson[i].box.height;
		dis1 = min(pCfgs->detLineParm[region_idx].detRight + 5, right) - max(pCfgs->detLineParm[region_idx].detLeft - 5, left);
		dis2 = min(pCfgs->detLineParm[region_idx].detBottom + 5, bottom) - max(pCfgs->detLineParm[region_idx].detTop - 5, top);
		//val1 = pCfgs->detLineParm[region_idx].k * left + pCfgs->detLineParm[region_idx].b - top;
		//val2 = pCfgs->detLineParm[region_idx].k * right + pCfgs->detLineParm[region_idx].b - bottom;
		//去除不在检测区域的目标
		if(dis1 >= 0 && dis2 >= 0)
		//if(dis1 >= 0 && val1 * val2 <= 0)
		{
			;
		}
		else if(pCfgs->objPerson[i].continue_num > 5)//目标存在大于5帧，防止检测框位置跳动
		{
	       /* if(pCfgs->objPerson[i].cal_flow == FALSE)//这里统计容易多检
			{
				get_object_num(pCfgs, i);
				pCfgs->objPerson[i].cal_flow = TRUE;
				//printf("%d,count 2\n",pCfgs->gThisFrameTime);
			}*/
			//DeleteTarget(&pCfgs->objPerson_size, &i, pCfgs->objPerson);
			//continue;
		}
		int isInRegion = RectInRegion(pParams->MaskDetectImage, pCfgs, width, height, pCfgs->objPerson[i].box, region_idx);
		//当目标在视频存在时间太长或长时间没有检测到或离开图像，删除目标
		if(isInRegion <= 2 || pCfgs->objPerson[i].continue_num > 5000 || pCfgs->objPerson[i].lost_detected > 5 || ((left < 10 || top < 10 || right > (width - 10)  || bottom > (height - 10))&& pCfgs->objPerson[i].lost_detected > 2))
		{
			/*if(pCfgs->objPerson[i].cal_flow == FALSE)
			{
				get_object_num(pCfgs, i);
			    pCfgs->objPerson[i].calflow = TRUE;
			}*/
			
            DeleteTarget(&pCfgs->objPerson_size, &i, pCfgs->objPerson);
			continue;

		}
		//保存行人目标框
		if(pCfgs->objPerson[i].detected)
		{
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].x = pCfgs->objPerson[i].box.x;
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].y = pCfgs->objPerson[i].box.y;
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].w = pCfgs->objPerson[i].box.width;
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].h = pCfgs->objPerson[i].box.height;
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].label = 0;
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].confidence = pCfgs->objPerson[i].prob;
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].id =pCfgs->objPerson[i].target_id;//目标id
			int pos_x = max(0, pCfgs->objPerson[i].box.x + pCfgs->objPerson[i].box.width / 2);
			pos_x = min(pos_x, width - 1);
			int pos_y =max(0, pCfgs->objPerson[i].box.y + pCfgs->objPerson[i].box.height / 2);
			pos_y = min(pos_y, height - 1);
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].distance[0] = pCfgs->image_actual[pos_y][pos_x][0];//目标与相机的水平距离
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].distance[1] = pCfgs->image_actual[pos_y][pos_x][1];//目标与相机的垂直距离
			pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].laneid = -1;//车道ID
			/*if(pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].w <= 0 || pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].h <= 0 || pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].w > width || pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].h > height)
			{
				prt(info," person box width = %d, height = %d",pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].w, pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].h);
			}*/
			//prt(info," person box width = %d, height = %d",pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].w, pCfgs->ResultMsg.uResultInfo.udetPersonBox[nPersonNum].h);
			nPersonNum++;
		}

		pCfgs->objPerson[i].continue_num++;
#ifdef SAVE_VIDEO
		cv::rectangle(img, cv::Rect(pCfgs->objPerson[i].box.x - 2, pCfgs->objPerson[i].box.y - 2, pCfgs->objPerson[i].box.width + 4, pCfgs->objPerson[i].box.height + 4), cv::Scalar(0, 255, 0), 1, 8, 0 );
		char str[10];
		sprintf(str, "%d", pCfgs->objPerson[i].target_id);
		putText(img, str, cv::Point(pCfgs->objPerson[i].box.x, max(0, pCfgs->objPerson[i].box.y - 10)), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255, 0 ), 2);
#endif

	}
	pCfgs->ResultMsg.uResultInfo.udetPersonNum = nPersonNum;
	printf("person num = %d\n",nPersonNum);
	//统计行人
	nPersonNum = 0;
	for(i = 1; i >= 0; i--)
	{
		pCfgs->uStatPersonNum[i + 1] = pCfgs->uStatPersonNum[i];
	}
	pCfgs->uStatPersonNum[0] = pCfgs->ResultMsg.uResultInfo.udetPersonNum;
	if(pCfgs->uStatPersonNum[3] < 3)
	{
		pCfgs->uStatPersonNum[3]++;
	}
	for(i = 0; i < pCfgs->uStatPersonNum[3]; i++)
	{
		nPersonNum = nPersonNum + pCfgs->uStatPersonNum[i];
	}
	pCfgs->ResultMsg.uResultInfo.udetStatPersonNum = (float)nPersonNum / pCfgs->uStatPersonNum[3];
#ifdef SAVE_VIDEO
	char str1[10];
	sprintf(str1, "%d", pCfgs->uPersonDirNum[0][0]);
	putText(img, str1, cv::Point(100, 30), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255, 0 ), 2);
	char str2[10];
	sprintf(str2, "%d", pCfgs->uPersonDirNum[0][1]);
	putText(img, str2, cv::Point(150, 30), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255, 0 ), 2);
#endif
	printf("person obj =%d, direction num = [%d,%d]\n",pCfgs->objPerson_size, pCfgs->uPersonDirNum[0][0], pCfgs->uPersonDirNum[0][1]);
	memcpy(pCfgs->uRegionPersonNum, uRegionPersonNum, MAX_REGION_NUM * sizeof(Uint16));//区域行人数
}
//处理车辆检测框，得到车流量
//void get_lane_params(ALGCFGS *pCfgs, ALGPARAMS *pParams, int laneNum, int imgW, int imgH)
//{
//	//printf("get_target start...................................\n");
//	CPoint ptCorner[MAX_LANE][16];
//	int i = 0, j = 0, k = 0;
//	int left = 0,right = 0, top = 0, bottom = 0;
//	int x1 = 0, x2 = 0, x3 = 0;
//	int maxValue = 0;
//	int maxLane = 0;
//	int dis = 0;
//	int lane_id = 0;
//	int cal_lane_id[2] = { 0 };
//	int nboxes1 = 0;
//	int vehicle_num[MAX_LANE] = { 0 };
//	int vehicle_num1[MAX_LANE] = {0};
//	bool obj_lost[MAX_LANE] = { FALSE };
//	int match_object[MAX_TARGET_NUM] = { 0 };
//	int match_rect[MAX_TARGET_NUM] = { 0 };
//	int match_success = -1, match_obj_idx = 0;
//	int overlap_x = 0, overlap_y = 0;
//	int det_match_object[MAX_TARGET_NUM] = { 0 };
//	int det_match_rect[MAX_TARGET_NUM] = { 0 };
//	int det_match_success = -1, det_match_obj_idx = 0;
//	float sum = 0.0;
//	int dis_x = 0, dis_y = 0;
//	int laneStatus[MAX_LANE][2] = { 0 };//车道占有状态
//	//车道坐标信息
//	for( i = 0; i < laneNum; i++)
//	{
//		ptCorner[i][0] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[0];
//		ptCorner[i][1] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[1];
//		ptCorner[i][2] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[3];
//		ptCorner[i][3] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[2];
//		ptCorner[i][4] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[0];
//	    ptCorner[i][5] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[1];
//		ptCorner[i][6] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[3];
//		ptCorner[i][7] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[2];
//		ptCorner[i][8] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0];
//		ptCorner[i][9] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1];
//		ptCorner[i][10] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[3];
//		ptCorner[i][11] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[2];
//		ptCorner[i][12] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[0];
//		ptCorner[i][13] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[1];
//		ptCorner[i][14] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3];
//		ptCorner[i][15] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2];
//		laneStatus[i][0] = 0;
//		laneStatus[i][1] = 0;
//		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag)
//			pCfgs->existFrameNum[i][0]++;
//		else
//			pCfgs->existFrameNum[i][0] = 0;
//		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag)
//			pCfgs->existFrameNum[i][1]++;
//		else
//			pCfgs->existFrameNum[i][1] = 0;
//		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag == 2)//流量线圈上一帧为出车状态，先置为0
//		{
//			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag = 0;
//		}
//		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag == 2)//后线圈上一帧为出车状态，先置为0
//		{
//			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag = 0;
//		}
//	}
//	memset(pCfgs->Tailposition, 0, laneNum * sizeof(Uint16));//头车位置
//	memset(pCfgs->Headposition, 10000, laneNum * sizeof(Uint16));//末车位置
//	//memset(pCfgs->uDetectVehicleSum, 0, laneNum * sizeof(Uint32));
//	memset(pCfgs->IsCarInTail, 0, laneNum * sizeof(bool));//尾部占有状态
//
//	for( i = 0; i < pCfgs->targets_size; i++)//设置未检测
//	{
//		pCfgs->targets[i].detected = FALSE;
//	}
//
//	//分析车辆检测框
//	for( i = 0; i < pCfgs->classes; i++)
//	{
//		if(strcmp(pCfgs->detClasses[i].names, "car") != 0 && strcmp(pCfgs->detClasses[i].names, "bus") != 0 && strcmp(pCfgs->detClasses[i].names, "truck") != 0)
//			continue;
//		if(pCfgs->detClasses[i].classes_num)
//		{
//			//目标和检测框进行匹配
//			match_object_rect(pCfgs->targets, pCfgs->targets_size, pCfgs->detClasses, i, match_object, match_rect, 10);
//			for( j = 0; j < pCfgs->detClasses[i].classes_num; j++)
//			{
//				//目标和检测框匹配，更新目标信息
//				match_success = -1;
//				for( k = 0; k < pCfgs->targets_size; k++)
//				{
//					if(match_object[j] == k && match_rect[k] == j)
//					{
//						match_success = 1;
//						pCfgs->targets[k].box = pCfgs->detClasses[i].box[j];
//						pCfgs->targets[k].prob = pCfgs->detClasses[i].prob[j];
//						pCfgs->targets[k].class_id = pCfgs->detClasses[i].class_id;
//						strcpy(pCfgs->targets[k].names, pCfgs->detClasses[i].names);
//						pCfgs->targets[k].detected = TRUE;
//						det_match_obj_idx = k;
//						break;
//					}
//				}
//				int overlapNum[MAX_LANE] = {-1};
//				left = max(0, pCfgs->detClasses[i].box[j].x);
//				right = min(pCfgs->detClasses[i].box[j].x + pCfgs->detClasses[i].box[j].width, imgW - 1);
//				top = max(0, pCfgs->detClasses[i].box[j].y);
//				bottom = min(pCfgs->detClasses[i].box[j].y + pCfgs->detClasses[i].box[j].height, imgH - 1);
//				for( k = 0; k < laneNum; k++)//计算与车道相交值
//				{
//					/*x1 = (float)((top + bottom) / 2 - ptCorner[k][0].y) * (float)(ptCorner[k][2].x - ptCorner[k][0].x) / (float)(ptCorner[k][2].y - ptCorner[k][0].y) + ptCorner[k][0].x;
//					x2 = (float)((top + bottom) / 2 - ptCorner[k][1].y) * (float)(ptCorner[k][3].x - ptCorner[k][1].x) / (float)(ptCorner[k][3].y - ptCorner[k][1].y) + ptCorner[k][1].x;
//					x3 = min(x2, right)-max(x1, left);
//					overlapNum[k] = x3;*/
//					overlapNum[k] = RectInRegion(pParams->MaskLaneImage, pCfgs, imgW, imgH, pCfgs->detClasses[i].box[j], k);
//				}
//				//找出相交最大车道
//				maxValue = overlapNum[0];
//				maxLane = 0;
//				for( k = 1; k < laneNum; k++)
//				{
//					if(maxValue < overlapNum[k])
//					{
//						maxValue = overlapNum[k];
//						maxLane = k;
//					}
//				}
//				//if(/*maxValue > 0*/maxValue >= (right - left) / 4)//(right - left) / 4
//				if(maxValue > 10)//检测框10%之上在车道内
//				{
//				    dis = min(max(ptCorner[maxLane][2].y, ptCorner[maxLane][3].y), bottom) - max(ptCorner[maxLane][0].y, top);
//					if(match_success == 1)
//					{
//						pCfgs->targets[det_match_obj_idx].lane_id = maxLane;
//					}
//					if( dis > 10 )//在占有区域到车道区域下端进行计数
//					{
//						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].x = pCfgs->detClasses[i].box[j].x;
//						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].y = pCfgs->detClasses[i].box[j].y;
//						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w = pCfgs->detClasses[i].box[j].width;
//						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h = pCfgs->detClasses[i].box[j].height;
//						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].label = pCfgs->detClasses[i].class_id + 1;
//						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].confidence = pCfgs->detClasses[i].prob[j];
//#ifdef SAVE_VIDEO
//		cv::rectangle(img, cv::Rect(pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].x,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].y,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h), cv::Scalar(0, 0 ,255), 1, 8, 0 );
//#endif
//						nboxes1++;
//						//vehicle_num[maxLane]++;
//						//pCfgs->uDetectVehicleSum[maxLane]++;//区域车辆数
//						//未匹配，增加新的目标
//						if(match_success < 0 && pCfgs->targets_size < MAX_TARGET_NUM)
//						{
//							CTarget nt; 
//							Initialize_target(&nt);
//							nt.box = pCfgs->detClasses[i].box[j];
//							nt.class_id = pCfgs->detClasses[i].class_id;
//							nt.prob = pCfgs->detClasses[i].prob[j];
//							nt.detected = TRUE;
//							nt.target_id = pCfgs->target_id++;
//							nt.lane_id = maxLane;
//							if(pCfgs->target_id > 5000)
//								pCfgs->target_id = 1;
//							//nt.start_time = pCfgs->currTime;
//							strcpy(nt.names, pCfgs->detClasses[i].names);
//							pCfgs->targets[pCfgs->targets_size] = nt;
//							pCfgs->targets_size++;
//						}
//					}
//					pCfgs->detClasses[i].lane_id[j] = maxLane;
//					vehicle_num1[maxLane]++;
//					pCfgs->Headposition[maxLane] = (pCfgs->Headposition[maxLane] > top)? top : pCfgs->Headposition[maxLane];//头车位置
//					pCfgs->Tailposition[maxLane] = (pCfgs->Tailposition[maxLane] < bottom)? bottom : pCfgs->Tailposition[maxLane];//末车位置
//					if(pCfgs->IsCarInTail[maxLane] == FALSE)
//					{
//						if(min(bottom,  ptCorner[maxLane][6].y) - max(top, ptCorner[maxLane][4].y) > 5 && min(right, ptCorner[maxLane][5].x) - max(left, ptCorner[maxLane][4].x) > 5)//尾部占有状态
//						{
//							pCfgs->IsCarInTail[maxLane] = TRUE;
//							//pCfgs->ResultMsg.uResultInfo.uEachLaneData[maxLane].SpeedDetectInfo1.CoilAttribute[1].calarflag = 1;
//
//						}
//					}
//				}
//				else
//				{
//					pCfgs->detClasses[i].lane_id[j] = -1;
//				}
//			}
//		}
//	}
//	//pCfgs->ResultMsg.uResultInfo.udetNum = nboxes1;    
//	//分析目标
//	for(i = 0;i < pCfgs->targets_size; i++)
//	{
//		//保存轨迹
//		pCfgs->targets[i].trajectory[pCfgs->targets[i].trajectory_num].x = pCfgs->targets[i].box.x + pCfgs->targets[i].box.width / 2;
//		pCfgs->targets[i].trajectory[pCfgs->targets[i].trajectory_num].y = pCfgs->targets[i].box.y + pCfgs->targets[i].box.height / 2;
//		pCfgs->targets[i].trajectory_num++;
//		//检测到，并更新速度
//		if(pCfgs->targets[i].detected)
//		{
//			pCfgs->targets[i].lost_detected = 0;
//            get_speed(&pCfgs->targets[i]);
//		}
//		else//未检测到
//		{
//			pCfgs->targets[i].lost_detected++;
//			pCfgs->targets[i].box.x += pCfgs->targets[i].vx;
//			pCfgs->targets[i].box.y += pCfgs->targets[i].vy;
//		}
//
//		lane_id = pCfgs->targets[i].lane_id;
//		left = pCfgs->targets[i].box.x;
//		right = pCfgs->targets[i].box.x + pCfgs->targets[i].box.width;
//		top = pCfgs->targets[i].box.y;
//		bottom = pCfgs->targets[i].box.y + pCfgs->targets[i].box.height;
//		dis_x = min(max(ptCorner[lane_id][13].x, ptCorner[lane_id][15].x) + 5, right) - max(min(ptCorner[lane_id][12].x, ptCorner[lane_id][14].x) - 5, left);
//		dis_y = min(max(ptCorner[lane_id][14].y, ptCorner[lane_id][15].y) + 5, bottom) - max(min(ptCorner[lane_id][12].y, ptCorner[lane_id][13].y) - 5, top);//计算与流量区域是否相交
//		if(dis_x > 10 && dis_y > 10 && pCfgs->targets[i].detected && pCfgs->targets[i].cal_flow == FALSE)//与流量检测区域相交
//		{
//			if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//此车道存在车
//			{
//				dis = min(ptCorner[lane_id][14].y, bottom) - max(ptCorner[lane_id][12].y, top);
//				if(dis > (ptCorner[lane_id][14].y - ptCorner[lane_id][12].y) / 2 )//当检测框在流量线圈占线圈一半以上，不删除目标，但加入新目标
//				//if(bottom > (ptCorner[lane_id][12].y + ptCorner[lane_id][14].y) / 2)//不删除目标，但加入新目标
//				{
//					for( k = 0; k < pCfgs->targets_size; k++)
//					{
//						if(pCfgs->targets[k].target_id == pCfgs->currFore_target_id[lane_id])
//						{
//							break;
//						}
//					}
//					if(k < pCfgs->targets_size)//先出车，再进车
//					{
//						obj_out_region(pCfgs, maxLane, &pCfgs->targets[k], 0);//流量线圈出车
//					}
//					if(k == pCfgs->targets_size)//此线圈不存在车，但是线圈还是红色
//					{
//						pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag = 2;//此帧先出车，下帧进入
//						pCfgs->currFore_target_id[lane_id] = pCfgs->targets[i].target_id;
//					}
//				}
//				else//防止误检，不增加新目标
//					continue;
//			}
//			else
//			{
//				pCfgs->currFore_target_id[lane_id] = pCfgs->targets[i].target_id;
//			}
//
//		}
//		//目标进入流量线圈进行计数
//		if(pCfgs->currFore_target_id[lane_id] == pCfgs->targets[i].target_id && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag == 0 && pCfgs->targets[i].cal_flow == FALSE)//车刚入线圈
//		{
//			obj_in_region(pCfgs, lane_id, 0);//流量线圈车入
//			if(strcmp(pCfgs->targets[i].names, "car") == 0)//car
//			{
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uCarFlow++;
//			}
//			if(strcmp(pCfgs->targets[i].names, "bus") == 0)//bus
//			{
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uBusFlow++;
//			}
//			if(strcmp(pCfgs->targets[i].names, "truck") == 0)//truck
//			{
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uTruckFlow++;
//			}
//			if(strcmp(pCfgs->targets[i].names, "bicycle") == 0)//bicycle
//			{
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uBicycleFlow++;
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.nVehicleFlow++;
//			}
//			if(strcmp(pCfgs->targets[i].names, "motorbike") == 0)//motorbike
//			{
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uMotorbikeFlow++;
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.nVehicleFlow++;
//			}
//			pCfgs->targets[i].cal_flow = TRUE;
//			pCfgs->targets[i].start_time[0] = pCfgs->currTime;//车进入流量线圈
//			pCfgs->targets[i].trajectory_id[0] = pCfgs->targets[i].trajectory_num - 1;
//			pCfgs->targets[i].cal_lane_id[0] = lane_id;//此车道进行了流量线圈流量计数
//			pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].uVehicleType = pCfgs->targets[i].class_id + 1;
//		}
//		//计算车速、车长
//		cal_lane_id[0] = pCfgs->targets[i].cal_lane_id[0];//计算流量所在的车道ID
//		if(pCfgs->targets[i].cal_speed[0] == FALSE && pCfgs->targets[i].cal_flow)//车已经进入流量线圈
//		{
//			dis = min(ptCorner[cal_lane_id[0]][14].y, bottom) - max(ptCorner[cal_lane_id[0]][12].y, top);
//			if(dis >= min(pCfgs->targets[i].box.height, ptCorner[cal_lane_id[0]][14].y - ptCorner[cal_lane_id[0]][12].y - 2))//当车辆到达流量区域下边缘
//			{
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[0]].SpeedDetectInfo1.CoilAttribute[0].DetectOutSum++;
//				//pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[0]].SpeedDetectInfo1.CoilAttribute[0].uVehicleType = pCfgs->targets[i].class_id + 1;
//				//clock_t end_time = clock();
//				//pCfgs->targets[i].end_time = (float)end_time / CLOCKS_PER_SEC;
//				pCfgs->targets[i].end_time[0] = pCfgs->currTime;
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[0]].SpeedDetectInfo1.CoilAttribute[0].uVehicleSpeed  = CalTargetSpeed(pCfgs->targets[i], cal_lane_id[0], pCfgs);
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[0]].SpeedDetectInfo1.CoilAttribute[0].uVehicleLength  = CalTargetLength(pCfgs->targets[i], cal_lane_id[0], pCfgs);
//				pCfgs->targets[i].cal_speed[0] = TRUE;
//			}
//		}
//#ifdef SAVE_VIDEO
//		cv::rectangle(img, cv::Rect(pCfgs->targets[i].box.x,pCfgs->targets[i].box.y,pCfgs->targets[i].box.width,pCfgs->targets[i].box.height), cv::Scalar(255, 255 ,255), 1, 8, 0 );
//		char str[10];
//		sprintf(str, "%d", pCfgs->targets[i].target_id);
//		putText(img, str, cv::Point(pCfgs->targets[i].box.x,max(0,pCfgs->targets[i].box.y - 10)), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
//		char str1[10];
//		sprintf(str1, "%d", pCfgs->currFore_target_id[lane_id]);
//		putText(img, str1, cv::Point(pCfgs->targets[i].box.x + 30,max(0,pCfgs->targets[i].box.y - 10)), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
//#endif
//		//判断与当前车道流量线圈是否相交
//		dis_x = min(max(ptCorner[cal_lane_id[0]][13].x, ptCorner[cal_lane_id[0]][15].x) + 5, right) - max(min(ptCorner[cal_lane_id[0]][12].x, ptCorner[cal_lane_id[0]][14].x) - 5, left);
//		dis_y = min(max(ptCorner[cal_lane_id[0]][14].y, ptCorner[cal_lane_id[0]][15].y) + 5, bottom) - max(min(ptCorner[cal_lane_id[0]][12].y, ptCorner[cal_lane_id[0]][13].y) - 5, top);
//		//去除不在检测区域的目标
//		if(dis_x > 0 && dis_y > 0)
//		{
//			laneStatus[cal_lane_id[0]][0] = 1;
//		}
//		else if(pCfgs->targets[i].continue_num > 3)
//		{
//			if(pCfgs->currFore_target_id[cal_lane_id[0]] == pCfgs->targets[i].target_id && pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[0]].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//线圈是红色出车
//			{
//				obj_out_region(pCfgs, cal_lane_id[0], &pCfgs->targets[i], 0);//车出
//			}
//		}
//
//		//判断与当前车道是否相交
//		dis_x = min(max(ptCorner[cal_lane_id[0]][1].x, ptCorner[cal_lane_id[0]][3].x), right) - max(min(ptCorner[cal_lane_id[0]][0].x, ptCorner[cal_lane_id[0]][2].x), left);
//		dis_y = min(max(ptCorner[cal_lane_id[0]][2].y, ptCorner[cal_lane_id[0]][3].y), bottom) - max(min(ptCorner[cal_lane_id[0]][0].y, ptCorner[cal_lane_id[0]][1].y), top);
//		if(dis_x < 0 || dis_y < 0)//与车道线圈不相交
//		{
//			if(pCfgs->targets[i].target_id == pCfgs->currRear_target_id[cal_lane_id[0]] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[0]].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//后线圈是红色
//			{
//				obj_out_region(pCfgs, cal_lane_id[0], &pCfgs->targets[i], 0);//流量线圈出车
//				obj_lost[cal_lane_id[0]] = TRUE;
//			}
//		}
//
//		//判断此目标是否进入占位线圈
//		if(min(bottom, ptCorner[lane_id][10].y) - max(top, ptCorner[lane_id][8].y) > 5 && pCfgs->targets[i].target_id != pCfgs->currRear_target_id[lane_id] && pCfgs->targets[i].cal_flow == FALSE)
//		{
//			//满足时间间隔条件，进行判断
//			if((pCfgs->gThisFrameTime - pCfgs->uRearIntervalNum[lane_id]) > 5 || pCfgs->uRearIntervalNum[lane_id] == 0)
//			{
//				//线圈已经有车辆存在
//				if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag)
//				{
//					for( k = 0; k < pCfgs->targets_size; k++)
//					{
//						if(pCfgs->targets[k].target_id == pCfgs->currRear_target_id[lane_id])
//						{
//							break;
//						}
//					}
//					//存在车辆
//					if(k < pCfgs->targets_size)//先出车，再进车
//					{
//						obj_out_region(pCfgs, lane_id, &pCfgs->targets[k], 1);//后线圈出车
//					}
//					//不存在车辆
//					if(k == pCfgs->targets_size)//此线圈不存在车，但是线圈还是红色
//					{
//						pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag = 0;
//					}
//
//				}
//				//printf("lane_id = %d, intervalnum = %d,calarflag = %d,curr_id = %d,%d\n",lane_id,pCfgs->uRearIntervalNum[lane_id],pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag, pCfgs->targets[k].target_id,pCfgs->targets[i].target_id);
//				pCfgs->currRear_target_id[lane_id] = pCfgs->targets[i].target_id;//赋予新的target_id
//				pCfgs->uRearIntervalNum[lane_id] = pCfgs->gThisFrameTime;
//			}
//		}
//		if(pCfgs->targets[i].target_id == pCfgs->currRear_target_id[lane_id] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag == 0 && pCfgs->targets[i].cal_flow == FALSE)
//		{
//			obj_in_region(pCfgs, lane_id, 1);//后线圈车入
//			pCfgs->targets[i].cal_flow = TRUE;
//			pCfgs->targets[i].start_time[1] = pCfgs->currTime;//车进占位线圈
//			pCfgs->targets[i].trajectory_id[1] = pCfgs->targets[i].trajectory_num - 1;
//			pCfgs->targets[i].cal_lane_id[1] = lane_id;//此车道进行了占位线圈流量计数
//			pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].uVehicleType = pCfgs->targets[i].class_id + 1;
//		}
//
//		cal_lane_id[1] = pCfgs->targets[i].cal_lane_id[1];//计算流量所在的车道ID
//		if(pCfgs->targets[i].cal_speed[1] == FALSE && pCfgs->targets[i].cal_flow)//车已经进入占位线圈
//		{
//			//计算后线圈的流量、车速、车长
//			dis = min(ptCorner[cal_lane_id[1]][10].y, bottom) - max(ptCorner[cal_lane_id[1]][8].y, top);
//			if(dis >= min(pCfgs->targets[i].box.height, ptCorner[cal_lane_id[1]][10].y - ptCorner[cal_lane_id[1]][8].y - 2))//当车辆到达流量区域下边缘
//			{
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[1]].SpeedDetectInfo1.CoilAttribute[1].DetectOutSum++;
//				//pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].uVehicleType = pCfgs->targets[i].class_id + 1;
//				pCfgs->targets[i].end_time[1] = pCfgs->currTime;
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[1]].SpeedDetectInfo1.CoilAttribute[1].uVehicleSpeed  = CalTargetSpeed(pCfgs->targets[i], cal_lane_id[1], pCfgs);
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[1]].SpeedDetectInfo1.CoilAttribute[1].uVehicleLength = CalTargetLength(pCfgs->targets[i], cal_lane_id[1], pCfgs);
//				pCfgs->targets[i].cal_speed[1] = TRUE;
//			}
//		}
//
//		//判断与当前车道占位线圈是否相交
//		dis_x = min(max(ptCorner[cal_lane_id[1]][9].x,ptCorner[cal_lane_id[1]][11].x) + 5, right) - max(min(ptCorner[cal_lane_id[1]][8].x,ptCorner[cal_lane_id[1]][10].x) - 5, left);
//		dis_y = min(max(ptCorner[cal_lane_id[1]][10].y,ptCorner[cal_lane_id[1]][11].y) + 5, bottom) - max(min(ptCorner[cal_lane_id[1]][8].y,ptCorner[cal_lane_id[1]][9].y) - 5, top);
//		if(dis_x > 0 && dis_y > 0)//与占位线圈相交
//		{
//			laneStatus[cal_lane_id[1]][1] = 1;
//
//		}
//		else//与占位线圈不相交
//		{
//			if(pCfgs->targets[i].target_id == pCfgs->currRear_target_id[cal_lane_id[1]] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[1]].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//线圈是红色
//			{
//				obj_out_region(pCfgs, cal_lane_id[1], &pCfgs->targets[i], 1);//后线圈出车
//			}
//
//		}
//
//		//判断与当前车道是否相交
//		dis_x = min(max(ptCorner[cal_lane_id[1]][1].x, ptCorner[cal_lane_id[1]][3].x), right) - max(min(ptCorner[cal_lane_id[1]][0].x, ptCorner[cal_lane_id[1]][2].x), left);
//		dis_y = min(max(ptCorner[cal_lane_id[1]][2].y, ptCorner[cal_lane_id[1]][3].y), bottom) - max(min(ptCorner[cal_lane_id[1]][0].y, ptCorner[cal_lane_id[1]][1].y), top);
//		if(dis_x < 0 || dis_y < 0)//与车道线圈不相交
//		{
//			if(pCfgs->targets[i].target_id == pCfgs->currRear_target_id[cal_lane_id[1]] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[1]].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//后线圈是红色
//			{
//				obj_out_region(pCfgs, cal_lane_id[1], &pCfgs->targets[i], 1);//后线圈出车
//			}
//		}
//		//当目标在视频存在时间太长或长时间没有检测到或离开图像，删除目标
//		bool isLost = FALSE;
//		isLost = pCfgs->targets[i].lost_detected > 5 && (strcmp(pCfgs->targets[i].names, "bus") != 0 &&  strcmp(pCfgs->targets[i].names, "truck") != 0 );
//		isLost = pCfgs->targets[i].lost_detected > 20 && (strcmp(pCfgs->targets[i].names, "bus") == 0 ||  strcmp(pCfgs->targets[i].names, "truck") == 0 );
//		//当目标在视频存在时间太长或长时间没有检测到或离开图像，删除目标
//		if(pCfgs->targets[i].continue_num > 5000 || isLost || (pCfgs->targets[i].lost_detected > 5 && (left < 5 || top < 5 || right >= (imgW - 5)  || bottom >= (imgH - 5))))
//		//if(pCfgs->targets[i].continue_num > 5000 /*|| (pCfgs->targets[i].lost_detected > 5 && dis <= 0)*/ || isLost/*pCfgs->targets[i].lost_detected > 5*/ || dis_x < 0 || dis_y < 0)//10
//		//if(pCfgs->targets[i].continue_num > 5000 || (pCfgs->targets[i].lost_detected > 5 && pCfgs->targets[i].box.y > ptCorner[lane_id][14].y)||(pCfgs->targets[i].lost_detected > 10 && (pCfgs->targets[i].box.y> ptCorner[lane_id][12].y))|| (pCfgs->targets[i].box.x < 0 || pCfgs->targets[i].box.y < 0 || (pCfgs->targets[i].box.x + pCfgs->targets[i].box.width) > imgW  ||((pCfgs->targets[i].box.y + pCfgs->targets[i].box.height) > imgH)))
//		{
//			if(pCfgs->currFore_target_id[cal_lane_id[0]] == pCfgs->targets[i].target_id && pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[0]].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//线圈是红色
//			{
//				obj_out_region(pCfgs, cal_lane_id[0], &pCfgs->targets[i], 0);//流量线圈出车
//			    obj_lost[cal_lane_id[0]] = TRUE;
//			}
//			if(pCfgs->targets[i].target_id == pCfgs->currRear_target_id[cal_lane_id[1]] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[cal_lane_id[1]].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//线圈是红色
//			{
//				obj_out_region(pCfgs, cal_lane_id[1], &pCfgs->targets[i], 1);//后线圈出车
//			}
//			DeleteTarget(&pCfgs->targets_size, &i, pCfgs->targets);
//			continue;
//
//		}
//
//		//得到跟踪框
//		dis = min(max(ptCorner[lane_id][2].y, ptCorner[lane_id][3].y), bottom) - max(min(ptCorner[lane_id][4].y, ptCorner[lane_id][5].y), top);
//		if(dis > 0)
//		{
//			//计算区域内的车辆数
//			vehicle_num[lane_id]++;
//			//将跟踪框代替检测框
//			//pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1++] = pCfgs->targets[i].box;
//			/*pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].x = pCfgs->targets[i].box.x;
//			pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].y = pCfgs->targets[i].box.y;
//			pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w = pCfgs->targets[i].box.width;
//			pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h = pCfgs->targets[i].box.height;
//			pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].label = pCfgs->targets[i].class_id + 1;
//			pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].confidence = pCfgs->targets[i].prob;
//			nboxes1++;*/
//		}
//		pCfgs->targets[i].continue_num++;
//
//	}
//	pCfgs->ResultMsg.uResultInfo.udetNum = nboxes1; 
//
//	//防止车辆跳变对区域车辆数进行处理
//	for( i = 0; i < laneNum; i++)
//	{
//		//判断是否与线圈相交
//		for(j = 0; j < 2; j++)
//		{
//			if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[j].calarflag == 1 && laneStatus[i][j] == 0 && pCfgs->existFrameNum[i][j] > 3)//没有目标在线圈内
//			{
//				if(j == 0)//流量线圈
//				{
//					for(k = 0; k < pCfgs->targets_size; k++)
//					{
//						if(pCfgs->currFore_target_id[i] == pCfgs->targets[k].target_id)
//							obj_out_region(pCfgs, i, &pCfgs->targets[k], 0);
//					}
//					if(k == pCfgs->targets_size)//没有目标
//					{
//						if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//车出线圈时，calarflag设置为2
//							pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag = 2;
//					}
//				}
//				if(j == 1)//后线圈
//				{
//					for(k = 0; k < pCfgs->targets_size; k++)
//					{
//						if(pCfgs->currRear_target_id[i] == pCfgs->targets[k].target_id)
//							obj_out_region(pCfgs, i, &pCfgs->targets[k], 1);
//					}
//					if(k == pCfgs->targets_size)//没有目标
//					{
//						if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//车出线圈时，calarflag设置为2
//							pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag = 2;
//					}
//
//				}
//				pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[j].calarflag = 2;
//				pCfgs->existFrameNum[i][j] = 0;
//			}
//		}
//		//printf("laneID = %d, vehicle num = %d\n",i,vehicle_num1[i]);
//		if(pCfgs->gThisFrameTime < 10)//对最初几帧不进行处理
//		{
//			pCfgs->uDetectVehicleSum[i] = vehicle_num[i];
//		}
//		else
//		{
//			int curr_num = vehicle_num[i];
//			//printf("lane id = %d,curr num = %d,old num =%d\n",i,curr_num,pCfgs->uDetectVehicleSum[i]);
//			if(pCfgs->uDetectVehicleSum[i] != curr_num)
//			{
//				if(pCfgs->uDetectVehicleFrameNum[i] > 10)//最短10帧才发生车辆数的变化
//				{
//					curr_num = (pCfgs->uDetectVehicleSum[i] > curr_num)? (pCfgs->uDetectVehicleSum[i] - 1) : (pCfgs->uDetectVehicleSum[i] + 1);
//				}
//				else if(pCfgs->uDetectVehicleSum[i] >  curr_num && obj_lost[i])//有车出
//				{
//					curr_num = pCfgs->uDetectVehicleSum[i] - 1;
//				}
//				else
//				{
//					curr_num = pCfgs->uDetectVehicleSum[i];
//				}
//				if(vehicle_num[i] == 0 && curr_num != 0)//当前帧没有区域车辆数，快速将车辆数降下
//				{
//					if(pCfgs->uDetectVehicleFrameNum[i] > 5)
//						curr_num = pCfgs->uDetectVehicleSum[i] - 1;
//				}
//			}
//			//printf("lane id1 = %d,curr num = %d,old num =%d interval_num =%d\n",i,curr_num,pCfgs->uDetectVehicleSum[i],pCfgs->uDetectVehicleFrameNum[i]);
//			if(pCfgs->uDetectVehicleSum[i] != curr_num)//前后两帧的车辆数不相同时，重新计数
//				pCfgs->uDetectVehicleFrameNum[i] = 0;
//			if(pCfgs->uDetectVehicleSum[i] == curr_num)//前后两帧车辆数相同
//				pCfgs->uDetectVehicleFrameNum[i]++;
//			pCfgs->uDetectVehicleSum[i] = curr_num;//将处理后的数量赋给当前车辆数
//		}
//		if(pCfgs->uDetectVehicleSum[i] == 0 || vehicle_num1[i] == 0)//车道区域内无车
//		{
//			pCfgs->Tailposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
//			pCfgs->Headposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
//		}
//	}
//
//	/*for( i = 0; i < laneNum; i++)
//	{
//		for( j = 1;j >= 0; j--)
//		{
//			pCfgs->uStatVehicleSum[i][j + 1] = pCfgs->uStatVehicleSum[i][j];
//		}
//		pCfgs->uStatVehicleSum[i][0] = vehicle_num[i];
//		if(pCfgs->uStatVehicleSum[i][3] < 3)
//			pCfgs->uStatVehicleSum[i][3] = pCfgs->uStatVehicleSum[i][3] + 1;
//
//		sum = 0.0;
//		for(j = 0; j < pCfgs->uStatVehicleSum[i][3];j++)
//			sum +=  pCfgs->uStatVehicleSum[i][j];
//		sum = sum / pCfgs->uStatVehicleSum[i][3];
//		//防止区域车辆数跳变
//		if(pCfgs->uDetectVehicleSum[i] > vehicle_num[i] && obj_lost[i])//有车出，数量减1
//		{
//			pCfgs->uDetectVehicleSum[i] = pCfgs->uDetectVehicleSum[i] - 1;
//		} 
//		else if(vehicle_num[i] > pCfgs->uDetectVehicleSum[i])
//		{
//			//pCfgs->uDetectVehicleSum[i] = vehicle_num[i];
//			pCfgs->uDetectVehicleSum[i] = sum + 0.5;
//		} 
//		else if(pCfgs->uDetectVehicleSum[i] > vehicle_num[i] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag == 0)//流量区域无车，采用实际检测数
//		{
//			//pCfgs->uDetectVehicleSum[i] = vehicle_num[i];//实际车辆数
//			//防止车辆数跳变
//			pCfgs->uDetectVehicleSum[i] = sum + 0.5;
//		}
//		if(vehicle_num[i] == 0)//车道区域内无车
//		{
//		pCfgs->Tailposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
//		pCfgs->Headposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
//		}
//#ifdef SAVE_VIDEO
//		char str[10];
//		sprintf(str, "%d", pCfgs->uDetectVehicleSum[i]);
//		putText(img, str, Point(10 + 30 * i,10), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
//		char str1[10];
//		sprintf(str1, "%d", pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].car_out);
//		putText(img, str1, Point(10 + 30 * i,30), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
//#endif
//	}*/
//	//printf("get_target end...................................\n");
//}
//处理车辆检测框，得到车流量
void get_lane_params(ALGCFGS *pCfgs, ALGPARAMS *pParams, int laneNum, int imgW, int imgH)
{
	//printf("get_target start...................................\n");
	CPoint ptCorner[MAX_LANE][16];
	int i = 0, j = 0, k = 0;
	int left = 0,right = 0, top = 0, bottom = 0;
	int x1 = 0, x2 = 0, x3 = 0;
	int maxValue = 0;
	int maxLane = 0;
	int dis = 0;
	int lane_id = 0;
	int nboxes1 = 0;
	int vehicle_num[MAX_LANE] = { 0 };
	int vehicle_num1[MAX_LANE] = {0};
	bool obj_lost[MAX_LANE] = { FALSE };
	int match_object[MAX_TARGET_NUM] = { 0 };
	int match_rect[MAX_TARGET_NUM] = { 0 };
	int match_success = -1, match_obj_idx = 0;
	int overlap_x = 0, overlap_y = 0;
	int det_match_object[MAX_TARGET_NUM] = { 0 };
	int det_match_rect[MAX_TARGET_NUM] = { 0 };
	int det_match_success = -1, det_match_obj_idx = 0;
	float sum = 0.0;
	int dis_x = 0, dis_y = 0;
	int laneStatus[MAX_LANE][2] = { 0 };//车道占有状态
	int lane_type = 0;//0   竖向车道   1 横向车道
	//车道坐标信息
	for( i = 0; i < laneNum; i++)
	{
		ptCorner[i][0] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[0];
		ptCorner[i][1] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[1];
		ptCorner[i][2] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[3];
		ptCorner[i][3] = pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[2];
		ptCorner[i][4] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[0];
		ptCorner[i][5] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[1];
		ptCorner[i][6] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[3];
		ptCorner[i][7] = pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[2];
		ptCorner[i][8] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0];
		ptCorner[i][9] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1];
		ptCorner[i][10] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[3];
		ptCorner[i][11] = pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[2];
		ptCorner[i][12] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[0];
		ptCorner[i][13] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[1];
		ptCorner[i][14] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3];
		ptCorner[i][15] = pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2];
		laneStatus[i][0] = 0;
		laneStatus[i][1] = 0;
		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag)
			pCfgs->existFrameNum[i][0]++;
		else
			pCfgs->existFrameNum[i][0] = 0;
		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag)
			pCfgs->existFrameNum[i][1]++;
		else
			pCfgs->existFrameNum[i][1] = 0;
		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag == 2)//流量线圈上一帧为出车状态，先置为0
		{
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag = 0;
		}
		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag == 2)//后线圈上一帧为出车状态，先置为0
		{
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag = 0;
		}
	}
	memset(pCfgs->Tailposition, 0, laneNum * sizeof(Uint16));//头车位置
	memset(pCfgs->Headposition, 10000, laneNum * sizeof(Uint16));//末车位置
	//memset(pCfgs->uDetectVehicleSum, 0, laneNum * sizeof(Uint32));
	memset(pCfgs->IsCarInTail, 0, laneNum * sizeof(bool));//尾部占有状态

	for( i = 0; i < pCfgs->targets_size; i++)//设置未检测
	{
		pCfgs->targets[i].detected = FALSE;
	}
	for( i = 0; i < pCfgs->detTargets_size; i++)//设置未检测
	{
		pCfgs->detTargets[i].detected = FALSE;
	}

	//分析车辆检测框
	for( i = 0; i < pCfgs->classes; i++)
	{
		if(strcmp(pCfgs->detClasses[i].names, "car") != 0 && strcmp(pCfgs->detClasses[i].names, "bus") != 0 && strcmp(pCfgs->detClasses[i].names, "truck") != 0)
			continue;
		if(pCfgs->detClasses[i].classes_num)
		{
			//目标和检测框进行匹配
			match_object_rect(pCfgs->targets, pCfgs->targets_size, pCfgs->detClasses, i, match_object, match_rect, 15);
			match_object_rect(pCfgs->detTargets, pCfgs->detTargets_size, pCfgs->detClasses, i, det_match_object, det_match_rect, 5);
			for( j = 0; j < pCfgs->detClasses[i].classes_num; j++)
			{
				//目标和检测框匹配，更新目标信息
				det_match_success = -1;
				for( k = 0; k < pCfgs->detTargets_size; k++)
				{
					if(det_match_object[j] == k && det_match_rect[k] == j)
					{
						det_match_success = 1;
						break;
					}
				}
				if(det_match_success == 1)
				{
					pCfgs->detTargets[k].box = pCfgs->detClasses[i].box[j];
					pCfgs->detTargets[k].prob = pCfgs->detClasses[i].prob[j];
					pCfgs->detTargets[k].class_id = pCfgs->detClasses[i].class_id;
					strcpy(pCfgs->detTargets[k].names, pCfgs->detClasses[i].names);
					pCfgs->detTargets[k].detected = TRUE;
					det_match_obj_idx = k;
				}
				match_success = -1;
				for( k = 0; k < pCfgs->targets_size; k++)
				{
					if(match_object[j] == k && match_rect[k] == j)
					{
						match_success = 1;
						pCfgs->targets[k].box = pCfgs->detClasses[i].box[j];
						pCfgs->targets[k].prob = pCfgs->detClasses[i].prob[j];
						pCfgs->targets[k].class_id = pCfgs->detClasses[i].class_id;
						strcpy(pCfgs->targets[k].names, pCfgs->detClasses[i].names);
						pCfgs->targets[k].detected = TRUE;
						break;
					}
				}
				int overlapNum[MAX_LANE] = {-1};
				left = max(0, pCfgs->detClasses[i].box[j].x);
				right = min(pCfgs->detClasses[i].box[j].x + pCfgs->detClasses[i].box[j].width, imgW - 1);
				top = max(0, pCfgs->detClasses[i].box[j].y);
				bottom = min(pCfgs->detClasses[i].box[j].y + pCfgs->detClasses[i].box[j].height, imgH - 1);
				for( k = 0; k < laneNum; k++)//计算与车道相交值
				{
					/*x1 = (float)((top + bottom) / 2 - ptCorner[k][0].y) * (float)(ptCorner[k][2].x - ptCorner[k][0].x) / (float)(ptCorner[k][2].y - ptCorner[k][0].y) + ptCorner[k][0].x;
					x2 = (float)((top + bottom) / 2 - ptCorner[k][1].y) * (float)(ptCorner[k][3].x - ptCorner[k][1].x) / (float)(ptCorner[k][3].y - ptCorner[k][1].y) + ptCorner[k][1].x;
					x3 = min(x2, right)-max(x1, left);
					overlapNum[k] = x3;*/
					overlapNum[k] = RectInRegion(pParams->MaskLaneImage, pCfgs, imgW, imgH, pCfgs->detClasses[i].box[j], k);
				}
				//找出相交最大车道
				maxValue = overlapNum[0];
				maxLane = 0;
				for( k = 1; k < laneNum; k++)
				{
					if(maxValue < overlapNum[k])
					{
						maxValue = overlapNum[k];
						maxLane = k;
					}
				}
				//if(/*maxValue > 0*/maxValue >= (right - left) / 4)//(right - left) / 4
				if(maxValue > 10)//检测框10%之上在车道内
				{
					dis_x = min(max(ptCorner[maxLane][1].x, ptCorner[maxLane][3].x), right) - max(min(ptCorner[maxLane][0].x, ptCorner[maxLane][2].x), left);
					dis_y = min(max(ptCorner[maxLane][2].y, ptCorner[maxLane][3].y), bottom) - max(min(ptCorner[maxLane][0].y, ptCorner[maxLane][1].y), top);
					if(det_match_success == 1)
					{
						pCfgs->detTargets[det_match_obj_idx].lane_id = maxLane;
					}
					if( dis_x  > 10 && dis_y > 10)//在占有区域到车道区域下端进行计数
					{
						/*pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].x = pCfgs->detClasses[i].box[j].x;
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].y = pCfgs->detClasses[i].box[j].y;
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w = pCfgs->detClasses[i].box[j].width;
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h = pCfgs->detClasses[i].box[j].height;
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].label = pCfgs->detClasses[i].class_id + 1;
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].confidence = pCfgs->detClasses[i].prob[j];
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].id = 0;//目标ID
						int pos_x = max(0, pCfgs->detClasses[i].box[j].x + pCfgs->detClasses[i].box[j].width / 2);
						pos_x = min(pos_x, imgW - 1);
						int pos_y =max(0, pCfgs->detClasses[i].box[j].y + pCfgs->detClasses[i].box[j].height / 2);
						pos_y = min(pos_y, imgH - 1);
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].distance[0] = pCfgs->image_actual[pos_y][pos_x][0];//目标与相机的水平距离
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].distance[1] = pCfgs->image_actual[pos_y][pos_x][1];//目标与相机的垂直距离
						pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].laneid = 0;//车道号
#ifdef SAVE_VIDEO
		cv::rectangle(img, cv::Rect(pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].x,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].y,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h), cv::Scalar(0, 0 ,255), 1, 8, 0 );
#endif
						nboxes1++;*/
						//vehicle_num[maxLane]++;
						//pCfgs->uDetectVehicleSum[maxLane]++;//区域车辆数
						//未匹配，增加新的目标
						if(det_match_success < 0)
						{
							CTarget nt; 
							Initialize_target(&nt);
							nt.box = pCfgs->detClasses[i].box[j];
							nt.class_id = pCfgs->detClasses[i].class_id;
							nt.prob = pCfgs->detClasses[i].prob[j];
							nt.detected = TRUE;
							nt.target_id = pCfgs->detTarget_id++;
							nt.lane_id = maxLane;
							if(pCfgs->detTarget_id > 5000)
								pCfgs->detTarget_id = 1;
							nt.start_time = pCfgs->currTime;
							strcpy(nt.names, pCfgs->detClasses[i].names);
							pCfgs->detTargets[pCfgs->detTargets_size] = nt;
							pCfgs->detTargets_size++;
						}
					}
					pCfgs->detClasses[i].lane_id[j] = maxLane;
					vehicle_num1[maxLane]++;
					pCfgs->Headposition[maxLane] = (pCfgs->Headposition[maxLane] > top)? top : pCfgs->Headposition[maxLane];//头车位置
					pCfgs->Tailposition[maxLane] = (pCfgs->Tailposition[maxLane] < bottom)? bottom : pCfgs->Tailposition[maxLane];//末车位置
					if(pCfgs->IsCarInTail[maxLane] == FALSE)
					{
						if(min(bottom,  ptCorner[maxLane][6].y) - max(top, ptCorner[maxLane][4].y) > 5 && min(right, ptCorner[maxLane][5].x) - max(left, ptCorner[maxLane][4].x) > 5)//尾部占有状态
						{
							pCfgs->IsCarInTail[maxLane] = TRUE;
							//pCfgs->ResultMsg.uResultInfo.uEachLaneData[maxLane].SpeedDetectInfo1.CoilAttribute[1].calarflag = 1;

						}
					}
					//与流量区域相交
					dis_x = min(ptCorner[maxLane][13].x, right) - max(ptCorner[maxLane][12].x, left);
					dis_y = min(ptCorner[maxLane][14].y, bottom) - max(ptCorner[maxLane][12].y, top);
					//if(min(ptCorner[maxLane][14].y, bottom) - max(ptCorner[maxLane][12].y, top) > 0)
					{
						if(match_success > 0)//匹配成功
						{
							;
						}
						else if(dis_x > 10 && dis_y > 10)//检测框与流量相交，增加新目标
						{
							if(top > max(ptCorner[maxLane][12].y, ptCorner[maxLane][2].y - 100))//防止误检,车top已经进入线圈，不再加入到目标中
								continue;
							/*for( k = 0; k < pCfgs->targets_size; k++)
							{
								if(pCfgs->targets[k].target_id == pCfgs->currFore_target_id[maxLane])
								{
									if(pCfgs->targets[k].cal_flow == FALSE)
									{
										break;
									}
								}
							}
							if(k < pCfgs->targets_size)//当前车道的目标ID还没有进行流量统计
								continue;*/
							if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[maxLane].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//此车道存在车
							{
								if((lane_type == 0 && dis_y > (ptCorner[maxLane][14].y - ptCorner[maxLane][12].y) / 2) || (lane_type == 1 && dis_x > (ptCorner[maxLane][13].x - ptCorner[maxLane][12].x) / 2))//当检测框在流量线圈占线圈一半以上，不删除目标，但加入新目标
								//if(bottom > (ptCorner[maxLane][12].y + ptCorner[maxLane][14].y) / 2)//不删除目标，但加入新目标
								{
									for( k = 0; k < pCfgs->targets_size; k++)
									{
										if(pCfgs->targets[k].target_id == pCfgs->currFore_target_id[maxLane])
										{
											break;
										}
									}
									if(k < pCfgs->targets_size)//先出车，再进车
									{
										obj_out_region(pCfgs, maxLane, &pCfgs->targets[k], 0);//流量线圈出车
									}
									if( k == pCfgs->targets_size)
									{
										pCfgs->ResultMsg.uResultInfo.uEachLaneData[maxLane].SpeedDetectInfo1.CoilAttribute[0].calarflag = 2;
									}
								}
								else//防止误检，不增加新目标
									continue;
							}
							//增加新的目标
							CTarget nt; 
							Initialize_target(&nt);
							nt.box = pCfgs->detClasses[i].box[j];
							nt.class_id = pCfgs->detClasses[i].class_id;
							nt.prob = pCfgs->detClasses[i].prob[j];
							nt.detected = TRUE;
							nt.target_id = pCfgs->target_id++;
							nt.lane_id = maxLane;
							//clock_t start_time = clock();
							//nt.start_time = (float)start_time / CLOCKS_PER_SEC;
							nt.start_time = pCfgs->currTime;
							if(pCfgs->target_id > 5000)
								pCfgs->target_id = 1;
							strcpy(nt.names, pCfgs->detClasses[i].names);
							//printf("%s\n",pCfgs->detClasses[i].names);
							pCfgs->targets[pCfgs->targets_size] = nt;
							pCfgs->targets_size++;
							//obj_in_region(pCfgs, maxLane, 0);//车入
							pCfgs->currFore_target_id[maxLane] = nt.target_id;

						}
					}
				}
				else
				{
					pCfgs->detClasses[i].lane_id[j] = -1;
				}
			}
		}
	}
	//pCfgs->ResultMsg.uResultInfo.udetNum = nboxes1;    
	//分析目标
	for(i = 0;i < pCfgs->targets_size; i++)
	{
		//保存轨迹
		pCfgs->targets[i].trajectory[pCfgs->targets[i].trajectory_num].x = pCfgs->targets[i].box.x + pCfgs->targets[i].box.width / 2;
		pCfgs->targets[i].trajectory[pCfgs->targets[i].trajectory_num].y = pCfgs->targets[i].box.y + pCfgs->targets[i].box.height / 2;
		pCfgs->targets[i].trajectory_num++;
		//检测到，并更新速度
		if(pCfgs->targets[i].detected)
		{
			pCfgs->targets[i].lost_detected = 0;
            get_speed(&pCfgs->targets[i]);
		}
		else//未检测到
		{
			pCfgs->targets[i].lost_detected++;
			pCfgs->targets[i].box.x += pCfgs->targets[i].vx;
			pCfgs->targets[i].box.y += pCfgs->targets[i].vy;
		}

		lane_id = pCfgs->targets[i].lane_id;
		left = pCfgs->targets[i].box.x;
		right = pCfgs->targets[i].box.x + pCfgs->targets[i].box.width;
		top = pCfgs->targets[i].box.y;
		bottom = pCfgs->targets[i].box.y + pCfgs->targets[i].box.height;
		dis_x = min(max(ptCorner[lane_id][13].x, ptCorner[lane_id][15].x) + 5, right) - max(min(ptCorner[lane_id][12].x, ptCorner[lane_id][14].x) - 5, left);
		dis_y = min(max(ptCorner[lane_id][14].y, ptCorner[lane_id][15].y) + 5, bottom) - max(min(ptCorner[lane_id][12].y, ptCorner[lane_id][13].y) - 5, top);
		//目标进入流量线圈进行计数
		if(pCfgs->currFore_target_id[lane_id] == pCfgs->targets[i].target_id && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag == 0 && pCfgs->targets[i].cal_flow == FALSE)//车刚入线圈
		{
			obj_in_region(pCfgs, lane_id, 0);//流量线圈车入
			if(strcmp(pCfgs->targets[i].names, "car") == 0)//car
			{
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uCarFlow++;
			}
			if(strcmp(pCfgs->targets[i].names, "bus") == 0)//bus
			{
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uBusFlow++;
			}
			if(strcmp(pCfgs->targets[i].names, "truck") == 0)//truck
			{
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uTruckFlow++;
			}
			if(strcmp(pCfgs->targets[i].names, "bicycle") == 0)//bicycle
			{
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uBicycleFlow++;
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.nVehicleFlow++;
			}
			if(strcmp(pCfgs->targets[i].names, "motorbike") == 0)//motorbike
			{
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.uMotorbikeFlow++;
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.nVehicleFlow++;
			}
			pCfgs->targets[i].cal_flow = TRUE;
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].uVehicleType = pCfgs->targets[i].class_id + 1;
		}
		//计算车速、车长
		if(pCfgs->currFore_target_id[lane_id] == pCfgs->targets[i].target_id && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//车已经进入线圈
		{
			//计算车速
			bool isTrue = FALSE;
			//lane_type = pCfgs->DownDetectCfg.FvdDetectCfg.EachLaneCfg[lane_id].LaneType;//0：竖向 1：横向
			isTrue = (dis_y >= min(pCfgs->targets[i].box.height, ptCorner[lane_id][14].y - ptCorner[lane_id][12].y - 2) && lane_type == 0) || (dis_x >= min(pCfgs->targets[i].box.width, ptCorner[lane_id][13].x - ptCorner[lane_id][12].x - 2) && lane_type == 1);
			dis = min(ptCorner[lane_id][14].y, bottom) - max(ptCorner[lane_id][12].y, top);
			if(isTrue && pCfgs->targets[i].cal_speed == FALSE && pCfgs->targets[i].continue_num)//当车辆到达流量区域下边缘
				//if(pCfgs->targets[i].box.y + pCfgs->targets[i].box.height > (ptCorner[lane_id][14].y + ptCorner[lane_id][15].y)/2 && pCfgs->targets[i].cal_speed == FALSE && pCfgs->targets[i].continue_num)//当车辆到达流量区域下边缘
			{
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].DetectOutSum++;
				//pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].uVehicleType = pCfgs->targets[i].class_id + 1;
				//clock_t end_time = clock();
				//pCfgs->targets[i].end_time = (float)end_time / CLOCKS_PER_SEC;
				pCfgs->targets[i].end_time = pCfgs->currTime;
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].uVehicleSpeed  = CalTargetSpeed(pCfgs->targets[i], lane_id, pCfgs);
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].uVehicleLength  = CalTargetLength(pCfgs->targets[i], lane_id, pCfgs);
				pCfgs->targets[i].cal_speed = TRUE;
			}
		}
		//防止框跳动，出车
		/*top = min(ptCorner[lane_id][12].y - 10, ptCorner[lane_id][13].y - 10);
		top = max(0, top);
		bottom = max(ptCorner[lane_id][14].y + 10, ptCorner[lane_id][15].y + 10);
		bottom = min(imgH - 1, bottom);
		dis = min(bottom, pCfgs->targets[i].box.y + pCfgs->targets[i].box.height) - max(top, pCfgs->targets[i].box.y);*/
		//计算与流量区域是否相交
		dis = min(ptCorner[lane_id][14].y, bottom) - max(ptCorner[lane_id][12].y, top);
		//判断与当前车道流量线圈是否相交
		if(dis_x > 0 && dis_y > 0)
		{
			laneStatus[lane_id][0] = 1;
		}
		else if(pCfgs->targets[i].continue_num > 3)
		{
			if(pCfgs->currFore_target_id[lane_id] == pCfgs->targets[i].target_id && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//线圈是红色出车
				obj_out_region(pCfgs, lane_id, &pCfgs->targets[i], 0);//车出
			obj_lost[lane_id] = TRUE;
			//DeleteTarget(&pCfgs->targets_size, &i, pCfgs->targets);//这里删除目标，容易导致跳动框删除目标，然后多计数
			//continue;
		}
		//判断与当前车道是否相交
		dis_x = min(max(ptCorner[lane_id][1].x, ptCorner[lane_id][3].x), right) - max(min(ptCorner[lane_id][0].x, ptCorner[lane_id][2].x), left);
		dis_y = min(max(ptCorner[lane_id][2].y, ptCorner[lane_id][3].y), bottom) - max(min(ptCorner[lane_id][0].y, ptCorner[lane_id][1].y), top);
		//当目标在视频存在时间太长或长时间没有检测到或离开图像，删除目标
		bool isLost = FALSE;
		if(strcmp(pCfgs->targets[i].names, "bus") == 0 ||  strcmp(pCfgs->targets[i].names, "truck") == 0)//公交车或卡车
		{
			isLost = (pCfgs->targets[i].lost_detected > 10);
		}
		else
		{
			isLost = (pCfgs->targets[i].lost_detected > 5);
		}
		if(pCfgs->targets[i].continue_num > 5000 /*|| (pCfgs->targets[i].lost_detected > 5 && dis <= 0)*/ || isLost/*pCfgs->targets[i].lost_detected > 5*/ || dis_x < 0 || dis_y < 0)//10
		//if(pCfgs->targets[i].continue_num > 5000 || (pCfgs->targets[i].lost_detected > 5 && pCfgs->targets[i].box.y > ptCorner[lane_id][14].y)||(pCfgs->targets[i].lost_detected > 10 && (pCfgs->targets[i].box.y> ptCorner[lane_id][12].y))|| (pCfgs->targets[i].box.x < 0 || pCfgs->targets[i].box.y < 0 || (pCfgs->targets[i].box.x + pCfgs->targets[i].box.width) > imgW  ||((pCfgs->targets[i].box.y + pCfgs->targets[i].box.height) > imgH)))
		{
			if(pCfgs->currFore_target_id[lane_id] == pCfgs->targets[i].target_id && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//线圈是红色
				obj_out_region(pCfgs, lane_id, &pCfgs->targets[i], 0);//车出
			obj_lost[lane_id] = TRUE;
			DeleteTarget(&pCfgs->targets_size, &i, pCfgs->targets);
			continue;

		}
#ifdef SAVE_VIDEO
		cv::rectangle(img, cv::Rect(pCfgs->targets[i].box.x,pCfgs->targets[i].box.y,pCfgs->targets[i].box.width,pCfgs->targets[i].box.height), cv::Scalar(255, 255 ,255), 1, 8, 0 );
		char str[10];
		sprintf(str, "%d", pCfgs->targets[i].target_id);
		putText(img, str, cv::Point(pCfgs->targets[i].box.x,max(0,pCfgs->targets[i].box.y - 10)), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
		char str1[10];
		sprintf(str1, "%d", pCfgs->currFore_target_id[lane_id]);
		putText(img, str1, cv::Point(pCfgs->targets[i].box.x + 30,max(0,pCfgs->targets[i].box.y - 10)), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
#endif
		pCfgs->targets[i].continue_num++;

	}

	//分析检测目标，并进行区域内的车辆数统计
	for(i = 0;i < pCfgs->detTargets_size; i++)
	{
		//保存轨迹
		pCfgs->detTargets[i].trajectory[pCfgs->detTargets[i].trajectory_num].x = pCfgs->detTargets[i].box.x + pCfgs->detTargets[i].box.width / 2;
		pCfgs->detTargets[i].trajectory[pCfgs->detTargets[i].trajectory_num].y = pCfgs->detTargets[i].box.y + pCfgs->detTargets[i].box.height / 2;
		pCfgs->detTargets[i].trajectory_num++;

		//检测到，并更新速度
		if(pCfgs->detTargets[i].detected)
		{
			pCfgs->detTargets[i].lost_detected = 0;
			//get_speed(&pCfgs->detTargets[i]);
		}
		else//未检测到
		{
			pCfgs->detTargets[i].lost_detected++;
			pCfgs->detTargets[i].box.x += pCfgs->detTargets[i].vx;
			pCfgs->detTargets[i].box.y += pCfgs->detTargets[i].vy;
		}

		lane_id = pCfgs->detTargets[i].lane_id;
		left = pCfgs->detTargets[i].box.x;
		right = pCfgs->detTargets[i].box.x + pCfgs->detTargets[i].box.width;
		top = pCfgs->detTargets[i].box.y;
		bottom = pCfgs->detTargets[i].box.y + pCfgs->detTargets[i].box.height;
		dis_x = min(max(ptCorner[lane_id][9].x,ptCorner[lane_id][11].x) + 5, right) - max(min(ptCorner[lane_id][8].x,ptCorner[lane_id][10].x) - 5, left);
		dis_y = min(max(ptCorner[lane_id][10].y,ptCorner[lane_id][11].y) + 5, bottom) - max(min(ptCorner[lane_id][8].y,ptCorner[lane_id][9].y) - 5, top);
		//判断此目标是否进入占位线圈
		if(dis_x > 10 && dis_y > 10 && pCfgs->detTargets[i].target_id != pCfgs->currRear_target_id[lane_id] && pCfgs->detTargets[i].cal_flow == FALSE)
		{
			//满足时间间隔条件，进行判断
			if((pCfgs->gThisFrameTime - pCfgs->uRearIntervalNum[lane_id]) > 5 || pCfgs->uRearIntervalNum[lane_id] == 0)
			{
				//线圈已经有车辆存在
				if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag)
				{
					for( k = 0; k < pCfgs->detTargets_size; k++)
					{
						if(pCfgs->detTargets[k].target_id == pCfgs->currRear_target_id[lane_id])
						{
							break;
						}
					}
					//存在车辆
					if(k < pCfgs->detTargets_size)//先出车，再进车
					{
						obj_out_region(pCfgs, lane_id, &pCfgs->detTargets[k], 1);//后线圈出车
					}
					if(k == pCfgs->detTargets_size)
					{
						pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag = 2;
					}
				}
				//printf("lane_id = %d, intervalnum = %d,calarflag = %d,curr_id = %d,%d\n",lane_id,pCfgs->uRearIntervalNum[lane_id],pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag, pCfgs->detTargets[k].target_id,pCfgs->detTargets[i].target_id);
				pCfgs->currRear_target_id[lane_id] = pCfgs->detTargets[i].target_id;//赋予新的target_id
				pCfgs->uRearIntervalNum[lane_id] = pCfgs->gThisFrameTime;

			}
		}

		if(pCfgs->detTargets[i].target_id == pCfgs->currRear_target_id[lane_id] && pCfgs->detTargets[i].cal_flow == FALSE)
		{
			obj_in_region(pCfgs, lane_id, 1);//后线圈车入
			pCfgs->detTargets[i].cal_flow = TRUE;
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].uVehicleType = pCfgs->detTargets[i].class_id + 1;
		}

		//判断与当前车道占位线圈是否相交
		if(dis_x > 0 && dis_y > 0)//与线圈相交
		{
			laneStatus[lane_id][1] = 1;

		}
		else//与线圈不相交
		{
			if(pCfgs->detTargets[i].target_id == pCfgs->currRear_target_id[lane_id] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//线圈是红色
			{
				obj_out_region(pCfgs, lane_id, &pCfgs->detTargets[i], 1);//后线圈出车
			}

		}

		if(pCfgs->detTargets[i].target_id == pCfgs->currRear_target_id[lane_id] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)
		{
			//计算后线圈的流量、车速、车长
			//计算车速
			bool isTrue = FALSE;
			//lane_type = pCfgs->DownDetectCfg.FvdDetectCfg.EachLaneCfg[lane_id].LaneType;//0：竖向 1：横向
			isTrue = (dis_y >= min(pCfgs->detTargets[i].box.height, ptCorner[lane_id][10].y - ptCorner[lane_id][8].y - 2) && lane_type == 0) || (dis_x >= min(pCfgs->detTargets[i].box.width, ptCorner[lane_id][9].x - ptCorner[lane_id][8].x - 2) && lane_type == 1);
			if(isTrue && pCfgs->detTargets[i].cal_speed == FALSE && pCfgs->detTargets[i].continue_num)//当车辆到达流量区域下边缘
			{
			    pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].DetectOutSum++;
				//pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].uVehicleType = pCfgs->detTargets[i].class_id + 1;
				pCfgs->detTargets[i].end_time = pCfgs->currTime;
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].uVehicleSpeed  = CalTargetSpeed(pCfgs->detTargets[i], lane_id, pCfgs);
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].uVehicleLength = CalTargetLength(pCfgs->detTargets[i], lane_id, pCfgs);
				pCfgs->detTargets[i].cal_speed = TRUE;
			}
		}

		lane_id = pCfgs->detTargets[i].lane_id;

		//防止框跳动，出车
		dis_x = min(max(ptCorner[lane_id][3].x, ptCorner[lane_id][5].x), right) - max(min(ptCorner[lane_id][2].x, ptCorner[lane_id][4].x), left);
		dis_y = min(max(ptCorner[lane_id][2].y, ptCorner[lane_id][3].y), bottom) - max(min(ptCorner[lane_id][4].y, ptCorner[lane_id][5].y), top);
		//去除不在检测区域的目标
		if(dis_x > 0 && dis_y > 0)
		{
			//计算区域内的车辆数
			vehicle_num[lane_id]++;
			//将跟踪框代替检测框
			//pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1++] = pCfgs->detTargets[i].box;
			if(pCfgs->detTargets[i].detected)
			{
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].x = pCfgs->detTargets[i].box.x;
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].y = pCfgs->detTargets[i].box.y;
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w = pCfgs->detTargets[i].box.width;
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h = pCfgs->detTargets[i].box.height;
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].label = pCfgs->detTargets[i].class_id + 1;
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].confidence = pCfgs->detTargets[i].prob;
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].id = pCfgs->detTargets[i].target_id;//目标ID
				int pos_x = max(0, pCfgs->detTargets[i].box.x + pCfgs->detTargets[i].box.width / 2);
				pos_x = min(pos_x, imgW - 1);
				int pos_y =max(0, pCfgs->detTargets[i].box.y + pCfgs->detTargets[i].box.height / 2);
				pos_y = min(pos_y, imgH - 1);
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].distance[0] = pCfgs->image_actual[pos_y][pos_x][0];//目标与相机的水平距离
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].distance[1] = pCfgs->image_actual[pos_y][pos_x][1];//目标与相机的垂直距离
				pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].laneid = pCfgs->detTargets[i].lane_id;//车道号
#ifdef SAVE_VIDEO
				cv::rectangle(img, cv::Rect(pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].x,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].y,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w,pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h), cv::Scalar(0, 0 ,255), 1, 8, 0 );
#endif
				/*if(pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w <= 0 || pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h <= 0 || pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w > imgW || pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h > imgH)
				{
					prt(info," box width = %d, height = %d",pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w, pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h);
				}*/
				//prt(info," box width = %d, height = %d",pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].w, pCfgs->ResultMsg.uResultInfo.udetBox[nboxes1].h);
				nboxes1++;
			}
		}
		else if(pCfgs->detTargets[i].continue_num > 5)
		{
			if(pCfgs->detTargets[i].target_id == pCfgs->currRear_target_id[lane_id] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//线圈是红色
			{
				obj_out_region(pCfgs, lane_id, &pCfgs->detTargets[i], 1);//后线圈出车
			}
			DeleteTarget(&pCfgs->detTargets_size, &i, pCfgs->detTargets);
			continue;
		}
		//当目标在视频存在时间太长或长时间没有检测到或离开图像，删除目标
		if(pCfgs->detTargets[i].continue_num > 5000 || pCfgs->detTargets[i].lost_detected > 5 ||(pCfgs->detTargets[i].lost_detected > 0 && (left < 10 || top < 10 || right >= (imgW - 10)  ||bottom >= (imgH - 10))))
		{
			if(pCfgs->detTargets[i].target_id == pCfgs->currRear_target_id[lane_id] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[lane_id].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//线圈是红色
			{
				obj_out_region(pCfgs, lane_id, &pCfgs->detTargets[i], 1);//后线圈出车
			}
			DeleteTarget(&pCfgs->detTargets_size, &i, pCfgs->detTargets);
			continue;

		}
		pCfgs->detTargets[i].continue_num++;

	}
	pCfgs->ResultMsg.uResultInfo.udetNum = nboxes1; 

	//防止车辆跳变对区域车辆数进行处理
	for( i = 0; i < laneNum; i++)
	{
		//判断是否与线圈相交
		for(j = 0; j < 2; j++)
		{
			if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[j].calarflag == 1 && laneStatus[i][j] == 0 && pCfgs->existFrameNum[i][j] > 3)//没有目标在线圈内
			{
				if(j == 0)//流量线圈
				{
					for(k = 0; k < pCfgs->targets_size; k++)
					{
						if(pCfgs->currFore_target_id[i] == pCfgs->targets[k].target_id)
							obj_out_region(pCfgs, i, &pCfgs->targets[k], 0);
					}
					if(k == pCfgs->targets_size)//没有目标
					{
						if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag == 1)//车出线圈时，calarflag设置为2
							pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag = 2;
					}
				}
				if(j == 1)//后线圈
				{
					for(k = 0; k < pCfgs->detTargets_size; k++)
					{
						if(pCfgs->currRear_target_id[i] == pCfgs->detTargets[k].target_id)
							obj_out_region(pCfgs, i, &pCfgs->detTargets[k], 1);
					}
					if(k == pCfgs->detTargets_size)//没有目标
					{
						if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag == 1)//车出线圈时，calarflag设置为2
							pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag = 2;
					}

				}
				pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[j].calarflag = 2;
				pCfgs->existFrameNum[i][j] = 0;
			}
		}
		//printf("laneID = %d, vehicle num = %d\n",i,vehicle_num1[i]);
		if(pCfgs->gThisFrameTime < 10)//对最初几帧不进行处理
		{
			pCfgs->uDetectVehicleSum[i] = vehicle_num[i];
		}
		else
		{
			int curr_num = vehicle_num[i];
			//printf("lane id = %d,curr num = %d,old num =%d\n",i,curr_num,pCfgs->uDetectVehicleSum[i]);
			if(pCfgs->uDetectVehicleSum[i] != curr_num)
			{
				if(pCfgs->uDetectVehicleFrameNum[i] > 10)//最短10帧才发生车辆数的变化
				{
					curr_num = (pCfgs->uDetectVehicleSum[i] > curr_num)? (pCfgs->uDetectVehicleSum[i] - 1) : (pCfgs->uDetectVehicleSum[i] + 1);
				}
				else if(pCfgs->uDetectVehicleSum[i] >  curr_num && obj_lost[i])//有车出
				{
					curr_num = pCfgs->uDetectVehicleSum[i] - 1;
				}
				else
				{
					curr_num = pCfgs->uDetectVehicleSum[i];
				}
				if(vehicle_num[i] == 0 && curr_num != 0)//当前帧没有区域车辆数，快速将车辆数降下
				{
					if(pCfgs->uDetectVehicleFrameNum[i] > 5)
						curr_num = pCfgs->uDetectVehicleSum[i] - 1;
				}
			}
			//printf("lane id1 = %d,curr num = %d,old num =%d interval_num =%d\n",i,curr_num,pCfgs->uDetectVehicleSum[i],pCfgs->uDetectVehicleFrameNum[i]);
			if(pCfgs->uDetectVehicleSum[i] != curr_num)//前后两帧的车辆数不相同时，重新计数
				pCfgs->uDetectVehicleFrameNum[i] = 0;
			if(pCfgs->uDetectVehicleSum[i] == curr_num)//前后两帧车辆数相同
				pCfgs->uDetectVehicleFrameNum[i]++;
			pCfgs->uDetectVehicleSum[i] = curr_num;//将处理后的数量赋给当前车辆数
		}
		if(pCfgs->uDetectVehicleSum[i] == 0 || vehicle_num1[i] == 0)//车道区域内无车
		{
			pCfgs->Tailposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
			pCfgs->Headposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
		}
	}

	/*for( i = 0; i < laneNum; i++)
	{
		for( j = 1;j >= 0; j--)
		{
			pCfgs->uStatVehicleSum[i][j + 1] = pCfgs->uStatVehicleSum[i][j];
		}
		pCfgs->uStatVehicleSum[i][0] = vehicle_num[i];
		if(pCfgs->uStatVehicleSum[i][3] < 3)
			pCfgs->uStatVehicleSum[i][3] = pCfgs->uStatVehicleSum[i][3] + 1;

		sum = 0.0;
		for(j = 0; j < pCfgs->uStatVehicleSum[i][3];j++)
			sum +=  pCfgs->uStatVehicleSum[i][j];
		sum = sum / pCfgs->uStatVehicleSum[i][3];
		//防止区域车辆数跳变
		if(pCfgs->uDetectVehicleSum[i] > vehicle_num[i] && obj_lost[i])//有车出，数量减1
		{
			pCfgs->uDetectVehicleSum[i] = pCfgs->uDetectVehicleSum[i] - 1;
		} 
		else if(vehicle_num[i] > pCfgs->uDetectVehicleSum[i])
		{
			//pCfgs->uDetectVehicleSum[i] = vehicle_num[i];
			pCfgs->uDetectVehicleSum[i] = sum + 0.5;
		} 
		else if(pCfgs->uDetectVehicleSum[i] > vehicle_num[i] && pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag == 0)//流量区域无车，采用实际检测数
		{
			//pCfgs->uDetectVehicleSum[i] = vehicle_num[i];//实际车辆数
			//防止车辆数跳变
			pCfgs->uDetectVehicleSum[i] = sum + 0.5;
		}
		if(vehicle_num[i] == 0)//车道区域内无车
		{
		pCfgs->Tailposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
		pCfgs->Headposition[i] = min(ptCorner[i][2].y, ptCorner[i][3].y);
		}
#ifdef SAVE_VIDEO
		char str[10];
		sprintf(str, "%d", pCfgs->uDetectVehicleSum[i]);
		putText(img, str, Point(10 + 30 * i,10), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
		char str1[10];
		sprintf(str1, "%d", pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].car_out);
		putText(img, str1, Point(10 + 30 * i,30), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
#endif
	}*/
	//printf("get_target end...................................\n");
}
Uint16 ArithProc(Uint16 ChNum, unsigned char *pInFrameBuf, unsigned char *pInuBuf, unsigned char *pInvBuf, int FrameWidth, int FrameHeight,\
				 RESULTMSG* outBuf, Int32 outSize, ALGCFGS *pCfgs, ALGPARAMS *pParams)
{
	Int32 i, j;
	float temp = 0;

	CPoint m_ptend[16];
	CPoint LineUp[2];
	CPoint LineUp1[2];
	int x1 = 0, x2 = 0, x3 = 0, x4 = 0;
	int thr = 10;
	int result[6 * MAX_DETECTION_NUM] = { 0 };
	int nboxes = 0;

	//pthread_self();
	//printf("(pCfgs %x,%x\n",pCfgs,pthread_self());fflush(NULL);
	//printf("(pCfgs %x\n",pCfgs->CameraCfg);
	//将图像限制在[0, FULL_COLS),[0, FULL_ROWS)
	if(FrameWidth <= 0 || FrameHeight <= 0)//没有图像数据
	{
		printf("img cannot be zero!\n");
		return 0;
	}
	//处理数据大小
	pCfgs->m_iHeight = (FrameHeight > FULL_ROWS)? FULL_ROWS : FrameHeight;
	pCfgs->m_iWidth = (FrameWidth > FULL_COLS)? FULL_COLS : FrameWidth;
	//printf("process,%d,%d,%d,%d\n",FrameHeight,FrameWidth,pCfgs->m_iHeight,pCfgs->m_iWidth);
	if(pCfgs->gThisFrameTime % 199 == 1)
	{
		//能见度计算
		thr = 8;
		pCfgs->up_visib_value++;
		pCfgs->fuzzydegree = fuzzy(pInFrameBuf, FrameWidth, FrameHeight);
		for (j = VISIB_LENGTH - 1; j > 0; j--)
		{
			pCfgs->visib_value[j] = pCfgs->visib_value[j - 1];
		}
		pCfgs->visib_value[0] = (int)(pCfgs->fuzzydegree);
		if (pCfgs->up_visib_value > VISIB_LENGTH)
		{
			pCfgs->visibility = visible_judge(pCfgs->visib_value, VISIB_LENGTH, thr);
		} 
		else
		{
			pCfgs->visibility = FALSE;
		}
		printf("fuzzy degree = %d\n",(int)(pCfgs->fuzzydegree));
		//视频异常计算
		if(Color_deviate(pInuBuf, pInvBuf, FrameWidth / 4, FrameHeight / 4))
			pCfgs->abnormal_time++;
		else
			pCfgs->abnormal_time = 0;	   
		pCfgs->fuzzyflag = (pCfgs->abnormal_time > 5)? TRUE : FALSE;
	}

	//设置车道掩模图像
	if(pCfgs->bMaskLaneImage == FALSE)
	{
		MaskLaneImage(pCfgs, pParams, FrameWidth, FrameHeight);
		pCfgs->bMaskLaneImage = TRUE;
	}
	//设置行人检测区域掩模图像
	if(pCfgs->bMaskDetectImage == FALSE)
	{
		MaskDetectImage(pCfgs, pParams, FrameWidth, FrameHeight);
		pCfgs->bMaskDetectImage = TRUE;
	}
	//标定图像
	if(pCfgs->bCalibrationImage == FALSE)
	{
		get_calibration_data(pCfgs, FrameWidth, FrameHeight);
		pCfgs->bCalibrationImage = TRUE;
	}
	gettimeofday(&pCfgs->time_end, NULL);
	if(pCfgs->gThisFrameTime == 0)
		pCfgs->currTime = 0;
	else
	pCfgs->currTime += (pCfgs->time_end.tv_sec - pCfgs->time_start.tv_sec) + (pCfgs->time_end.tv_usec - pCfgs->time_start.tv_usec)/1000000.0;
	gettimeofday(&pCfgs->time_start, NULL);

	pCfgs->gThisFrameTime++;
	////////////////////////////////////////////////
	//将yuv转化成bgr
	Mat YUVImage, BGRImage;
	int size = FrameWidth * FrameHeight;
	//yuv420 to bgr
	YUVImage.create(FrameHeight * 3 / 2, FrameWidth, CV_8UC1);
	memcpy(YUVImage.data, pInFrameBuf, size);
	memcpy(YUVImage.data + size, pInuBuf, size / 4);
	memcpy(YUVImage.data + size + size / 4, pInvBuf, size / 4);
	cvtColor(YUVImage, BGRImage, CV_YUV2BGR_I420);
	YUVImage.release();
#ifdef DETECT_GPU  
	/*IplImage img = IplImage(BGRImage);
	//printf("image size = %d,%d,[%d,%d]\n",img.width,img.height,pCfgs->net_params->net->h,pCfgs->net_params->net->w);
	if(pCfgs->net_params->net)
	{
		nboxes = YoloArithDetect(&img, pCfgs->net_params, result);//yolo检测
	}*/
	IplImage* img = cvCreateImage(cvSize(FrameWidth, FrameHeight), IPL_DEPTH_8U, 3);
	memcpy(img->imageData, BGRImage.data, FrameHeight * FrameWidth * 3);
	//printf("image size = %d,%d,[%d,%d]\n",img.width,img.height,pCfgs->net_params->net->h,pCfgs->net_params->net->w);
	if(pCfgs->net_params->net)
	{
		nboxes = YoloArithDetect(img, pCfgs->net_params, result);//yolo检测
	}
	cvReleaseImage(&img);
#else
	nboxes = NCSArithDetect(BGRImage, pCfgs, result);
#endif
	//////////////////////////////////////////////////////
	memset((void *)&pCfgs->ResultMsg, 0, sizeof(pCfgs->ResultMsg));
	memcpy((void *)&pCfgs->ResultMsg, (void *)outBuf, outSize);
	//分析检测结果
	ProcessDetectBox(pCfgs, result, nboxes);
	//分析行人检测框
	ProcessPersonBox(pCfgs, pParams, FrameWidth, FrameHeight);
	//分析车辆检测框，得到车道检测参数
	get_lane_params(pCfgs, pParams, pCfgs->LaneAmount, FrameWidth, FrameHeight);

	//交通事件检测
	EventDetectProc(pCfgs, pParams, FrameWidth, FrameHeight);

#ifdef DETECT_PERSON_ATTRIBUTE
	HumanAttributeDetect(pCfgs, &img);//进行行人属性识别
	//BicycleAttributeDetect(pCfgs, img);//进行单车属性识别
#endif

#ifdef DETECT_PLATE//车牌识别
	/*PlateInfo plateInfo[MAX_PLATE_NUM];
	if(pCfgs->plate_flag >= 0)
	{
		int plateNum = PlateDetectandRecognize(BGRImage, 0, plateInfo, pCfgs->plate_flag);
		printf("plate num = %d\n",plateNum);
	}*/
	//给出车牌区域进行识别
	if(pCfgs->plate_flag >= 0)//加载车牌识别网络成功
	{
		PlateInfo plateInfo[MAX_PLATE_NUM];
		int plate_num = 0;
		for(i = 0; i < pCfgs->classes; i++)
		{
			strcpy(pCfgs->detClasses[i].names, LABELS[i]);
			if(strcmp(LABELS[i], "plate") != 0 || pCfgs->detClasses[i].classes_num <= 0)
				continue;
			for(j = 0; j < pCfgs->detClasses[i].classes_num; j++)
			{
				cv::Rect rct(pCfgs->detClasses[i].box[j].x, pCfgs->detClasses[i].box[j].y, pCfgs->detClasses[i].box[j].width, pCfgs->detClasses[i].box[j].height);
				//扩展车牌区域
				int minX = rct.x - rct.width * 0.15;
				int maxX = rct.x + rct.width + rct.width * 0.30;
				int minY = rct.y - rct.height / 2;
				int maxY = rct.y + 2 * rct.height;
				minX = max(0, minX);
				maxX = min(maxX, BGRImage.cols - 1);
				minY = max(0, minY);
				maxY = min(maxY, BGRImage.rows - 1);
				rct = Rect(minX, minY, maxX - minX + 1, maxY - minY + 1);
				Mat PlateROI = BGRImage(rct);
				plateInfo[plate_num]= PlateRecognizeOnly(PlateROI, 0, pCfgs->plate_flag);
				printf("num = %d, name = %s, type = %d, confidence = %f\n", plate_num, plateInfo[plate_num].plateName, plateInfo[plate_num].plateType, plateInfo[plate_num].confidence);
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].x = pCfgs->detClasses[i].box[j].x;
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].y = pCfgs->detClasses[i].box[j].y;
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].w = pCfgs->detClasses[i].box[j].width;
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].h = pCfgs->detClasses[i].box[j].height;
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].label = pCfgs->detClasses[i].class_id + 1;
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].confidence = pCfgs->detClasses[i].prob[j];
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].id = 0;//目标ID
				int pos_x = max(0, pCfgs->detClasses[i].box[j].x + pCfgs->detClasses[i].box[j].width / 2);
				pos_x = min(pos_x, imgW - 1);
				int pos_y =max(0, pCfgs->detClasses[i].box[j].y + pCfgs->detClasses[i].box[j].height / 2);
				pos_y = min(pos_y, imgH - 1);
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].distance = pCfgs->image_actual[pos_y][pos_x][1];//目标与相机的垂直距离

				for( j = 0; j < laneNum; j++)//计算与车道相交值
				{
					int overlapNum = RectInRegion(pParams->MaskLaneImage, pCfgs, FrameWidth, FrameHeight, pCfgs->detClasses[i].box[j], j);
					if(overlapNum > 50)
						break;
				}
				pCfgs->ResultMsg.uResultInfo.udetPlateBox[plate_num].laneid = j;//车道号
				/*cv::rectangle(BGRImage, rct, cv::Scalar(255, 255 ,255), 1, 8, 0 );
				cv::imwrite("result.jpg",BGRImage);*/
				plate_num++;
			}
		}
		pCfgs->ResultMsg.uResultInfo.udetPlateNum = plate_num;
	}
#endif
	BGRImage.release();

	pCfgs->uCongestionNum = 0;//拥堵数初始化
	pCfgs->ResultMsg.uResultInfo.LaneSum = pCfgs->LaneAmount;//车道数

	//缩放图像
	Mat grayImage, resizeImage;
	grayImage.create(FrameHeight, FrameWidth, CV_8UC1);
	memcpy(grayImage.data, pInFrameBuf, FrameHeight * FrameWidth);
	if(pCfgs->m_iWidth != FrameWidth || pCfgs->m_iHeight != FrameHeight)
		resize(grayImage, resizeImage, Size(pCfgs->m_iWidth, pCfgs->m_iHeight), 0, 0, INTER_LINEAR);//缩放
	else
		grayImage.copyTo(resizeImage);//复制
	grayImage.release();
	memcpy((void *)pParams->CurrQueueImage, (void *)resizeImage.data, pCfgs->m_iWidth * pCfgs->m_iHeight);
	memset(pCfgs->CongestionBox, 0, MAX_LANE * sizeof(EVENTBOX));//初始化拥堵框

	//计算车道内的排队长度
	for( i = 0; i < pCfgs->LaneAmount; i++ )
	{

		m_ptend[0]= pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[0]; 
		m_ptend[1]= pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[1];
		m_ptend[2]= pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[3];  
		m_ptend[3]= pCfgs->DownDetectCfg.SpeedEachLane[i].LaneRegion[2];//车道区域
		m_ptend[4]= pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[0];  
		m_ptend[5]= pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[1];
		m_ptend[6]= pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[3];  
		m_ptend[7]= pCfgs->DownDetectCfg.SpeedEachLane[i].FrontCoil[2]; //占位线圈		
		m_ptend[8]= pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0];  
		m_ptend[9]= pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1];
		m_ptend[10]= pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[3];  
		m_ptend[11]= pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[2];//占有线圈
		m_ptend[12]= pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[0];  
		m_ptend[13]= pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[1];
		m_ptend[14]= pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3];  
		m_ptend[15]= pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2];//流量线圈

		QueLengthCaculate( i, pCfgs, pParams, m_ptend, FrameWidth, FrameHeight);
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.getQueback_flag = 1;
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.IsCarInTailFlag = pCfgs->IsCarInTail[i];
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uDetectRegionVehiSum = pCfgs->uDetectVehicleSum[i];


		LineUp[0].x = LineUp[0].y = LineUp[1].x = LineUp[1].y = 0;
		LineUp1[0].x = LineUp1[0].y =LineUp1[1].x = LineUp1[1].y = 0;
		//末车位置

		if(m_ptend[0].y != m_ptend[2].y && m_ptend[1].y != m_ptend[3].y)
		{
			LineUp[0].y = pCfgs->Headposition[i];
			LineUp[1].y = pCfgs->Headposition[i];
			if(m_ptend[0].x == m_ptend[3].x)//垂直车道线
			{
				LineUp[0].x = m_ptend[0].x;
			}
			else
			{
				LineUp[0].x = (LineUp[0].y - m_ptend[0].y) * (m_ptend[3].x - m_ptend[0].x) / (m_ptend[3].y - m_ptend[0].y) + m_ptend[0].x;
			}
			if(m_ptend[1].x == m_ptend[2].x)//垂直车道线
			{
				LineUp[1].x = m_ptend[1].x;
			}	
			else
			{
				LineUp[1].x = (LineUp[1].y - m_ptend[1].y) * (m_ptend[2].x - m_ptend[1].x) / (m_ptend[2].y - m_ptend[1].y) + m_ptend[1].x;
			}
		}
		else
		{
			printf("detect point err\n");
		}
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.LineUp[0] = LineUp[0];
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.LineUp[1] = LineUp[1];

		//头车位置、末车位置、 头车速度、末车速度
		if(pCfgs->uDetectVehicleSum[i] == 0)
		{
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uHeadVehiclePos = 0;//头车位置
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uLastVehiclePos = 0;//末车位置
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uHeadVehicleSpeed = 0;//头车速度
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uLastVehicleSpeed = 0;//末车速度
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uVehicleDensity = 0;//车辆密度
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uLastVehicleLength = 0;//最后一辆车位置
		}
		else
		{	
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uHeadVehiclePos = pCfgs->actual_distance[i][pCfgs->Tailposition[i]];//头车位置
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uLastVehiclePos =pCfgs->actual_distance[i][pCfgs->Headposition[i]];//末车位置
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uHeadVehicleSpeed = pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].uVehicleSpeed;//头车速度
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uLastVehicleSpeed = pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].uVehicleSpeed;//末车速度
			//最后一辆车的位置
			temp = pCfgs->actual_distance[i][pCfgs->Headposition[i]];
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uLastVehicleLength = temp;

		}

		//排队长度
		if(m_ptend[0].y != m_ptend[3].y && m_ptend[1].y != m_ptend[2].y)
		{
			LineUp1[0].y = min(m_ptend[2].y, m_ptend[3].y);
			//LineUp1[0].x = (m_ptend[2].x + m_ptend[3].x) / 2 ;
			//LineUp1[0].y = ( m_ptend[2].y + m_ptend[3].y) / 2 ;

			LineUp1[1].y = pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uVehicleQueueLength;
			if(m_ptend[0].x == m_ptend[3].x)//垂直车道线
			{
				x1 = m_ptend[0].x;
				x3 = m_ptend[0].x;
			}
			else
			{
				x1 = (LineUp1[1].y - m_ptend[0].y) * (m_ptend[3].x - m_ptend[0].x) / (m_ptend[3].y - m_ptend[0].y) + m_ptend[0].x;
				x3 = (LineUp1[0].y - m_ptend[0].y) * (m_ptend[3].x - m_ptend[0].x) / (m_ptend[3].y - m_ptend[0].y) + m_ptend[0].x;
			}
			if(m_ptend[1].x == m_ptend[2].x)//垂直车道线
			{
				x2 = m_ptend[1].x;
				x4 = m_ptend[1].x;
			}	
			else
			{
				x2 = (LineUp1[1].y - m_ptend[1].y) * (m_ptend[2].x - m_ptend[1].x) / (m_ptend[2].y - m_ptend[1].y) + m_ptend[1].x;
				x4 = (LineUp1[0].y - m_ptend[1].y) * (m_ptend[2].x - m_ptend[1].x) / (m_ptend[2].y - m_ptend[1].y) + m_ptend[1].x;
			}
			LineUp1[1].x = (x1 + x2) / 2;
			LineUp1[0].x = (x3 + x4) / 2;
		}
		else
		{
			printf("detect point err\n");
		} 
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.QueLine[0] = LineUp1[0];//队首
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.QueLine[1] = LineUp1[1];//队尾
		if(abs(LineUp1[0].y - LineUp1[1].y) < 5)//没有排队	
		{	
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uQueueHeadDis = 0;//队首距离
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uQueueTailDis = 0;//队尾距离
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uVehicleQueueLength = 0;//排队长度

		}
		else
		{
			temp = pCfgs->actual_distance[i][LineUp1[0].y];	
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uQueueHeadDis = temp;//队首距离
			temp = pCfgs->actual_distance[i][LineUp1[1].y];	
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uQueueTailDis = temp;//队尾距离
			pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uVehicleQueueLength = pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uQueueTailDis;//从停车线开始
			//pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uVehicleQueueLength = abs(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uQueueTailDis - pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.uQueueHeadDis);//队首减队尾  排队长度
		}
#ifdef SAVE_VIDEO
		cv::line(img, cv::Point(pCfgs->detLineParm[0].pt[0].x,pCfgs->detLineParm[0].pt[0].y),cv::Point(pCfgs->detLineParm[0].pt[1].x,pCfgs->detLineParm[0].pt[1].y), cv::Scalar(255, 0 ,0), 1, 8, 0 );
		cv::line(img, cv::Point(m_ptend[0].x,m_ptend[0].y),cv::Point(m_ptend[3].x,m_ptend[3].y), cv::Scalar(255, 0 ,0), 1, 8, 0 );
		cv::line(img, cv::Point(m_ptend[1].x,m_ptend[1].y),cv::Point(m_ptend[2].x,m_ptend[2].y), cv::Scalar(255, 0 ,0), 1, 8, 0 );
		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].calarflag)
		{
			cv::line(img, cv::Point(m_ptend[12].x,m_ptend[12].y),cv::Point(m_ptend[13].x,m_ptend[13].y), cv::Scalar(0, 0 ,255), 1, 8, 0 );
			cv::line(img, cv::Point(m_ptend[14].x,m_ptend[14].y),cv::Point(m_ptend[15].x,m_ptend[15].y), cv::Scalar(0, 0 ,255), 1, 8, 0 );
		}
		else
		{
			cv::line(img, cv::Point(m_ptend[12].x,m_ptend[12].y),cv::Point(m_ptend[13].x,m_ptend[13].y), cv::Scalar(255, 0 ,0), 1, 8, 0 );
			cv::line(img, cv::Point(m_ptend[14].x,m_ptend[14].y),cv::Point(m_ptend[15].x,m_ptend[15].y), cv::Scalar(255, 0 ,0), 1, 8, 0 );
		}
		if(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].calarflag)
		{
			cv::line(img, cv::Point(m_ptend[8].x,m_ptend[8].y),cv::Point(m_ptend[9].x,m_ptend[9].y), cv::Scalar(0, 0 ,255), 1, 8, 0 );
			cv::line(img, cv::Point(m_ptend[10].x,m_ptend[10].y),cv::Point(m_ptend[11].x,m_ptend[11].y), cv::Scalar(0, 0 ,255), 1, 8, 0 );
		}
		else
		{
			cv::line(img, cv::Point(m_ptend[8].x,m_ptend[8].y),cv::Point(m_ptend[9].x,m_ptend[9].y), cv::Scalar(255, 0 ,0), 1, 8, 0 );
			cv::line(img, cv::Point(m_ptend[10].x,m_ptend[10].y),cv::Point(m_ptend[11].x,m_ptend[11].y), cv::Scalar(255, 0 ,0), 1, 8, 0 );
		}

		cv::line(img, cv::Point(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.QueLine[0].x,pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.QueLine[0].y),cv::Point(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.QueLine[1].x,pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.QueLine[1].y), cv::Scalar(0, 255 ,0), 3, 8, 0 );
		//cv::line(img, cv::Point(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.LineUp[0].x,pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.LineUp[0].y),cv::Point(pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.LineUp[1].x,pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.LineUp[1].y), cv::Scalar(255, 0 ,0), 3, 8, 0 );
		if(pCfgs->IsCarInTail[i])
		{
			cv::line(img, cv::Point(m_ptend[4].x,m_ptend[4].y),cv::Point(m_ptend[5].x,m_ptend[5].y), cv::Scalar(0, 0 ,255), 1, 8, 0);
			cv::line(img, cv::Point(m_ptend[6].x,m_ptend[6].y),cv::Point(m_ptend[7].x,m_ptend[7].y), cv::Scalar(0, 0 ,255), 1, 8, 0);
		}
		else
		{
			cv::line(img, cv::Point(m_ptend[4].x,m_ptend[4].y),cv::Point(m_ptend[5].x,m_ptend[5].y), cv::Scalar(255, 0 ,0), 1, 8, 0);
			cv::line(img, cv::Point(m_ptend[6].x,m_ptend[6].y),cv::Point(m_ptend[7].x,m_ptend[7].y), cv::Scalar(255, 0 ,0), 1, 8, 0);
		}
		char str[10];
		sprintf(str, "%d", pCfgs->gThisFrameTime);
		putText(img, str, cv::Point(320,30), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
		char str1[10];
		sprintf(str1, "%d", pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].DetectInSum);
		putText(img, str1, cv::Point(10 + 50 * i, 60), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
		char str2[10];
		sprintf(str2, "%d", pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[0].DetectOutSum);
		putText(img, str2, cv::Point(10 + 50 * i, 90), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
		char str3[10];
		sprintf(str3, "%d", pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].DetectInSum);
		putText(img, str3, cv::Point(10 + 50 * i, 180), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
		char str4[10];
		sprintf(str4, "%d", pCfgs->ResultMsg.uResultInfo.uEachLaneData[i].SpeedDetectInfo1.CoilAttribute[1].DetectOutSum);
		putText(img, str4, cv::Point(10 + 50 * i, 210), cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);

#endif
	}
	memcpy((void *)pParams->PrePrePreQueueImage, (void *)pParams->PrePreQueueImage, pCfgs->m_iWidth * pCfgs->m_iHeight);
	memcpy((void *)pParams->PrePreQueueImage, (void *)pParams->PreQueueImage, pCfgs->m_iWidth * pCfgs->m_iHeight);
	memcpy((void *)pParams->PreQueueImage, (void *)pParams->CurrQueueImage, pCfgs->m_iWidth * pCfgs->m_iHeight);
#ifdef SAVE_VIDEO
	 writer << img; 
	 if(pCfgs->gThisFrameTime > SAVE_FRAMES)
		 writer.release();
	 //imshow("img",img);
	 //waitKey(1);
#endif 
	 BGRImage.release();
	pCfgs->ResultMsg.uResultInfo.uEnvironmentStatus = pCfgs->bAuto; //added by david 20131014
	memcpy((void *)outBuf, (void *)&pCfgs->ResultMsg, outSize);
	return 1;
}
//按照位置顺序对检测框进行排序
void sort_obj(int obj_pos[][2], int obj_num)
{
	int temp[2];
	int i = 0, j = 0;
	for(i = 0; i < obj_num - 1; i++)

	{
		for(j = i + 1; j < obj_num; j++)

        {
			if(obj_pos[i][0] < obj_pos[j][0])
			{
				temp[0] = obj_pos[i][0];
				temp[1] = obj_pos[i][1];
				obj_pos[i][0] = obj_pos[j][0];
				obj_pos[i][1] = obj_pos[j][1];
				obj_pos[j][0] = temp[0];
				obj_pos[j][1] = temp[1];
			}
		}
	}

}
//是否排队
bool IsVehicleQueue(Uint8* puSubImage, Uint8* puMaskImage, Uint16 laneID, Uint16 tail_line, Uint16 head_line, ALGCFGS *pCfgs)
{
	int nRow, nCol;
	int subnum = 0, num = 0;
	float ratio = 0.0;
	Uint32 offset = 0;
	unsigned char* subPtr;
	unsigned char* maskPtr;
	//计算运动点数
	for( nRow =tail_line ; nRow < head_line; nRow++ )
	{
		offset = nRow * pCfgs->m_iWidth;
		subPtr = puSubImage + offset;
		maskPtr = puMaskImage + offset;
		for (nCol = 0 ; nCol < pCfgs->m_iWidth; nCol++)
		{
			if(maskPtr[nCol] == (laneID + 1))
			{
				if (subPtr[nCol])
				{
					subnum++;
				}
				num++;
			}
		}
	}
	ratio = (num > 0)? (float)subnum / (float)num : 0;
	if(ratio < 0.15)//0.15  小于阈值，则认为此区域不运动
	{
		return true;
	} 
	else
	{
		return false;
	}
}
Uint16 sort_median(Uint16* arr, int num)//取中间值
{
	int i = 0, j = 0;
	Uint16 temp;
	Uint16 array_temp[10] = {0};
	for(i = 0; i < num; i++)
	{
		array_temp[i] = arr[i];
	}
	for(i = 0; i <= num / 2; i++)
	{
		for(j = i + 1; j < num; j++)
		{
			if(array_temp[i] > array_temp[j])
			{
				temp = array_temp[i];
				array_temp[i] = array_temp[j];
				array_temp[j] = temp;
			}
		}
	}
	return array_temp[num / 2];
}
//计算车道是否拥堵
void CongestionDetect(Uint16 LaneID, ALGCFGS *pCfgs, int obj_pos[][2], int obj_num, CPoint m_ptend[], float* obj_interval, bool* IsVehStatic)
{
	int i = 0;
	int lane_top = MIN(m_ptend[0].y, m_ptend[1].y);
	int lane_bottom = MIN(m_ptend[2].y, m_ptend[3].y);
	int start_congestion = lane_bottom;
	int end_congestion = lane_bottom;
	bool bCongestion = FALSE;
	int cal_congestion = 0;//开始计算拥堵
	float sum = 0.0;
	int num = 0;
	int tolerate_num = 0;//允许车辆区域间隔大的数目
	int vehicle_static_num = 0;//静止车辆数量
	int x1 = 0, x2 = 0, x3 = 0, x4 = 0;
	int congestion_num = 0, totalnum = 0;
	//判断拥堵情况
	/*for( i = obj_num - 1; i >= 0; i--)//从上向下判断
	{
		//根据目标的距离判断拥堵情况
		if(obj_interval[i] < 0.3 && cal_congestion == 0)
		{
			start_congestion = obj_pos[i][1];
			cal_congestion = 1;
			sum = 0;
			num = 0;
			tolerate_num = 0;
		}
		else if(obj_interval[i] > 1 && cal_congestion)
		{
			tolerate_num++;
		}
		if(obj_interval[i] > 2)
		{
			break;
		}
		if(cal_congestion)
		{
			sum += (obj_interval[i] < 0) ? 0 : obj_interval[i];
			num++;
			if(sum /num < 0.5)
			{
				end_congestion = obj_pos[i][0];
			}
			if(sum / num > 0.5 || tolerate_num >= 2)
			{
				if((end_congestion - start_congestion) >= (lane_bottom - lane_top) / 3)//此段已经达到拥堵条件,不再继续分析
				{
					cal_congestion = 0;
					break;
				}
				else//重新判断
				{
					start_congestion = obj_pos[i][0];
					end_congestion = obj_pos[i][0];
					cal_congestion = 0;
				}
			}

		}
	}
	if((end_congestion - start_congestion) >= (lane_bottom - lane_top) / 3 && obj_num >=  4)//此帧为拥堵
	{
		bCongestion = TRUE;
	}
	pCfgs->CongestionBox[LaneID].uNewEventFlag = 0;
	//printf("congestion:[%d,%d],%d,%d,%d\n",end_congestion,start_congestion,obj_num,bCongestion,pCfgs->uStatCongestionNum[LaneID]);
	if(pCfgs->bStatCongestion[LaneID][0])
		pCfgs->uStatCongestionNum[LaneID]--;
	if(bCongestion)
		pCfgs->uStatCongestionNum[LaneID]++;
	for(i = 1; i < 150; i++)//将拥堵情况加入统计数组中
	{
		pCfgs->bStatCongestion[LaneID][i - 1] = pCfgs->bStatCongestion[LaneID][i];
	}
	pCfgs->bStatCongestion[LaneID][149] = bCongestion;
	if(pCfgs->uStatCongestionNum[LaneID] > 140 && pCfgs->bCongestion[LaneID] == FALSE && bCongestion)//当拥堵数达到一定数目时，为拥堵
	{
		pCfgs->CongestionBox[LaneID].uNewEventFlag = 1;
	}
	else if(pCfgs->uStatCongestionNum[LaneID] < 50 && pCfgs->bCongestion[LaneID] == TRUE && bCongestion == FALSE)//当拥堵数降为一定数目，为不拥堵
	{
		pCfgs->bCongestion[LaneID] = FALSE;
	}
	if(pCfgs->CongestionBox[LaneID].uNewEventFlag == 1)//新产生的拥堵事件 
	{
		pCfgs->bCongestion[LaneID] = TRUE;
		pCfgs->CongestionBox[LaneID].uEventID = pCfgs->eventID++;
	}*/
	for( i = obj_num - 1; i >= 0; i--)//从上向下判断
	{
		if(IsVehStatic[i])//统计静止车辆数
		{
			vehicle_static_num++;
		}
		//根据目标的距离判断拥堵情况
		if(obj_interval[i] < 0.3 && cal_congestion == 0)
		{
			start_congestion = obj_pos[i][1];
			cal_congestion = 1;
			sum = 0;
			num = 0;
			tolerate_num = 0;
		}
		else if(obj_interval[i] > 1 && cal_congestion)
		{
			tolerate_num++;
		}
		if(obj_interval[i] > 2)
		{
			break;
		}
		if(cal_congestion)
		{
			sum += (obj_interval[i] < 0) ? 0 : obj_interval[i];
			num++;
			if(sum /num < 0.5)
			{
				end_congestion = obj_pos[i][0];
			}
			if(sum / num > 0.5 || tolerate_num >= 2)
			{
				if((end_congestion - start_congestion) >= (lane_bottom - lane_top) / 2)//此段已经达到拥堵条件,不再继续分析
				{
					cal_congestion = 0;
					break;
				}
				else//重新判断
				{
					start_congestion = obj_pos[i][0];
					end_congestion = obj_pos[i][0];
					cal_congestion = 0;
				}
			}

		}
	}
	//printf("lane id = %d, obj_num = %d, static_num = %d, start_congestion = %d, end_congestion = %d\n", LaneID, obj_num, vehicle_static_num, start_congestion, end_congestion);
	if(vehicle_static_num >= 4 && (end_congestion - start_congestion) >= (lane_bottom - lane_top) / 2)//有4辆以上的车辆静止，并且拥堵达到一定长度,则此帧拥堵
		bCongestion = TRUE;
	//对拥堵情况进行分析
	pCfgs->CongestionBox[LaneID].uNewEventFlag = 0;

	for(i = 1; i < 150; i++)//将拥堵情况加入统计数组中,保存每帧实际时间
	{
		pCfgs->bStatCongestion[LaneID][i - 1] = pCfgs->bStatCongestion[LaneID][i];
	}
	pCfgs->bStatCongestion[LaneID][149] = bCongestion;

	if(pCfgs->bCongestion[LaneID] == FALSE && bCongestion)//判断是否满足拥堵条件
	{
		congestion_num = 0;
		totalnum = 0;
		for( i = 149; i >= 0; i--)
		{
			if(pCfgs->bStatCongestion[LaneID][i])
				congestion_num++;
			totalnum++;
			if((pCfgs->currTime - pCfgs->uStatFrameTime[0][i]) > pCfgs->uCongestionThreshTime)//当拥堵达到一定时间间隔，认为拥堵
			{
				if((float)congestion_num / (float)totalnum > 0.95)
				{
					pCfgs->CongestionBox[LaneID].uNewEventFlag = 1;
				}
				break;
			}
		}
		if(i == -1)
		{
			if((float)congestion_num / (float)totalnum > 0.95)
			{
				pCfgs->CongestionBox[LaneID].uNewEventFlag = 1;
			}
		}
	}
	if(pCfgs->bCongestion[LaneID] == TRUE && bCongestion == FALSE)//判断是否结束拥堵条件
	{
		congestion_num = 0;
		totalnum = 0;
		for( i = 149; i >= 0; i--)
		{
			if(pCfgs->bStatCongestion[LaneID][i])
				congestion_num++;
			totalnum++;
			if((pCfgs->currTime - pCfgs->uStatFrameTime[0][i]) > 2)//当达到不拥堵条件时，设置此车道不拥堵
			{
				if((float)congestion_num / (float)totalnum < 0.5)
				{
					pCfgs->bCongestion[LaneID] = FALSE;
				}
				break;
			}
		}
	}
	if(pCfgs->CongestionBox[LaneID].uNewEventFlag == 1 && (pCfgs->currTime - pCfgs->uCongestionTime[LaneID]) > (pCfgs->EventDetectCfg.ReportInterval[CONGESTION] * 60))//新产生的拥堵事件，并且达到前后拥堵的时间阈值
	{
		printf("congestion\n");
		pCfgs->bCongestion[LaneID] = TRUE;
		pCfgs->CongestionBox[LaneID].uEventID = pCfgs->eventID++;
		pCfgs->uCongestionTime[LaneID] = pCfgs->currTime;//上一次拥堵时间
	}
	/*if(bCongestion)
	{
		printf("Congestion = %d %d,%d\n",bCongestion, pCfgs->bCongestion[LaneID],pCfgs->uStatCongestionNum[LaneID]);
	}*/
	//计算拥堵线
	if(pCfgs->bCongestion[LaneID])
	{
		pCfgs->uCongestionNum++;
		if(m_ptend[0].y != m_ptend[2].y && m_ptend[1].y != m_ptend[3].y)
		{
			if(m_ptend[0].x == m_ptend[2].x)
			{
				x1 = m_ptend[0].x;
				x3 = m_ptend[0].x;
			}
			else
			{
				x1 = (start_congestion - m_ptend[0].y) * (m_ptend[2].x - m_ptend[0].x) / (m_ptend[2].y - m_ptend[0].y) + m_ptend[0].x;
				x3 = (end_congestion- m_ptend[0].y) * (m_ptend[2].x - m_ptend[0].x) / (m_ptend[2].y - m_ptend[0].y) + m_ptend[0].x;
			}
			if(m_ptend[1].x == m_ptend[3].x)
			{
				x2 = m_ptend[1].x;
				x4 = m_ptend[1].x;
			}	
			else
			{
				x2 = (start_congestion - m_ptend[1].y) * (m_ptend[3].x - m_ptend[1].x) / (m_ptend[3].y - m_ptend[1].y) + m_ptend[1].x;
				x4 = (end_congestion - m_ptend[1].y) * (m_ptend[3].x - m_ptend[1].x) / (m_ptend[3].y - m_ptend[1].y) + m_ptend[1].x;
			}
			pCfgs->CongestionBox[LaneID].EventBox[0].x = x1;
			pCfgs->CongestionBox[LaneID].EventBox[0].y = start_congestion;
			pCfgs->CongestionBox[LaneID].EventBox[1].x = x2;
			pCfgs->CongestionBox[LaneID].EventBox[1].y = start_congestion;
			pCfgs->CongestionBox[LaneID].EventBox[2].x = x4;
			pCfgs->CongestionBox[LaneID].EventBox[2].y = end_congestion;
			pCfgs->CongestionBox[LaneID].EventBox[3].x = x3;
			pCfgs->CongestionBox[LaneID].EventBox[3].y = end_congestion;
		}
	}

}
//计算排队长度
void QueLengthCaculate(Uint16 LaneID, ALGCFGS *pCfgs, ALGPARAMS	*pParams, CPoint m_ptend[], int width, int height)
{
	int i = 0, j = 0;
	int top = 0, bottom = 0;
	int obj_pos[50][2];//车辆框位置
	int obj_num = 0;//车辆框数量
	int lane_top = min(m_ptend[0].y, m_ptend[1].y);//车道最上端
	int lane_bottom = min(m_ptend[2].y, m_ptend[3].y);//车道最下端
	int que_pos = lane_bottom, que_pos1 = 0;
	float obj_interval[50]={0};//框间距
	int no_interval_num = 0;
	bool IsVehStatic[50]; //车辆位置是否静止
	float sum = 0.0;
	int stat_num = 0, num = 0;
	int QueVehicleNum = 0;//排队区域内车辆数量
	int actual_dis = 0;
	//根据运动情况和车辆数进行排队长度计算
	//iSubStractImage(pParams->CurrQueueImage, pParams->PreQueueImage, 15, 0, pCfgs->team_height, pCfgs->team_width, pCfgs->team_height);
	iSubStractImage(pParams->CurrQueueImage, pParams->PrePrePreQueueImage, pParams->MaskLaneImage, 15, LaneID, pCfgs->m_iWidth, pCfgs->m_iHeight);//隔三帧帧差
	/*//根据检测框进行排队长度分析
	for( i = 0; i < pCfgs->classes; i++)
	{
		if(pCfgs->detClasses[i].classes_num)
		{
			for( j = 0; j < pCfgs->detClasses[i].classes_num; j++)
			{
				if(pCfgs->detClasses[i].lane_id[j] == LaneID)
				{
					bottom = min(pCfgs->detClasses[i].box[j].y + pCfgs->detClasses[i].box[j].height, lane_bottom);
					top = min(pCfgs->detClasses[i].box[j].y, lane_bottom);
					if(bottom - top > 5)
					{
						if(obj_num < MAX_LANE_TARGET_NUM)
						{
							pCfgs->detBoxes[LaneID][obj_num] = pCfgs->detClasses[i].box[j];
						}//save
						obj_pos[obj_num][0] = bottom;
						obj_pos[obj_num][1] = top;
						obj_num++;
					}
				}
			}
		}
	}*/
	////根据跟踪框进行排队长度分析
	for( i = 0; i < pCfgs->detTargets_size; i++)
	{
		if(pCfgs->detTargets[i].lane_id == LaneID)
		{
			bottom = min(pCfgs->detTargets[i].box.y + pCfgs->detTargets[i].box.height, lane_bottom);
			top = min(pCfgs->detTargets[i].box.y, lane_bottom);
			if(bottom - top > 5)
			{
				if(obj_num < MAX_LANE_TARGET_NUM)
				{
					pCfgs->detBoxes[LaneID][obj_num] = pCfgs->detTargets[i].box;
				}//save
				obj_pos[obj_num][0] = bottom;
				obj_pos[obj_num][1] = top;
				obj_num++;
			}
		}
	}

	pCfgs->detNum[LaneID] = (obj_num > MAX_LANE_TARGET_NUM)? MAX_LANE_TARGET_NUM : obj_num;
	sort_obj(obj_pos, obj_num);//排序，从下向上
	for( i = 0; i < obj_num; i++)//计算每个框的间隔值和运动情况
	{
		if(i == 0)
		{
			obj_interval[i] = (float)(lane_bottom - obj_pos[i][0])/(float)(obj_pos[i][0] - obj_pos[i][1]);
			//sum += obj_interval[i];
			sum += (lane_bottom - obj_pos[i][0] < 0)? 0 : (lane_bottom - obj_pos[i][0]);//不是车辆的行数
		}
		if(i != 0)
		{
			obj_interval[i] = (float)(obj_pos[i - 1][1] - obj_pos[i][0])/(float)(obj_pos[i][0] - obj_pos[i][1]);
			//sum += obj_interval[i];
			if(obj_interval[i] <= 0)
				no_interval_num++;
			else
				no_interval_num = 0;
			sum += (obj_pos[i - 1][1] - obj_pos[i][0] < 0)? 0 :(obj_pos[i - 1][1] - obj_pos[i][0]);//不是车辆的行数
			actual_dis += (pCfgs->actual_distance[LaneID][obj_pos[i][0]] - pCfgs->actual_distance[LaneID][obj_pos[i - 1][1]]) * (pCfgs->actual_distance[LaneID][obj_pos[i][0]] - pCfgs->actual_distance[LaneID][obj_pos[i - 1][1]]);//车辆之间距离方差
		}
		if(i == obj_num - 1)
		{
			sum += (obj_pos[i][1] - lane_top < 0)? 0 :(obj_pos[i][1] - lane_top);//不是车辆的行数
		}
		IsVehStatic[i] = IsVehicleQueue(pParams->PrePrePreQueueImage, pParams->MaskLaneImage, LaneID, max(0, obj_pos[i][1] * pCfgs->m_iHeight / height), max(0, min(pCfgs->m_iHeight - 1, obj_pos[i][0] * pCfgs->m_iHeight / height)), pCfgs);
	}
	actual_dis = (obj_num > 1)? actual_dis / (obj_num - 1) : 0;
	//分析排队情况
	for( i = 0; i < obj_num; i++)
	{
		if(obj_interval[i] > 2)
		{
			break;
		}
		if(i == 1 && IsVehStatic[i] == FALSE && IsVehStatic[i - 1] == FALSE)
		{
			break;
		}
		if((IsVehStatic[i] && obj_interval[i] < 0.2 && (i == 0)) || (IsVehStatic[i] && IsVehStatic[i - 1] && obj_interval[i] < 0.5 && (i != 0)))// 0.1  0.5
		{
			que_pos = obj_pos[i][1];
		}
	}
	//printf("id =%d,vehicle_num = %d\n",LaneID,obj_num);

	//sum = (obj_num)? sum / obj_num : 0;
	/*if(obj_num > 3 && sum < 0.1 && no_interval_num > 0)
	{
		que_pos = obj_pos[obj_num - 1][1];
	}*/
	//统计得到排队长度
	stat_num = pCfgs->uStatQuePos[LaneID][5];
	if(stat_num < 5)
	{
		pCfgs->uStatQuePos[LaneID][stat_num] = que_pos;
		pCfgs->uStatQuePos[LaneID][5] = pCfgs->uStatQuePos[LaneID][5] + 1;
		stat_num = stat_num + 1;
	}
	else
	{
		for(num = 1; num < 5; num++)
		{
			pCfgs->uStatQuePos[LaneID][num - 1] = pCfgs->uStatQuePos[LaneID][num];
		}
		pCfgs->uStatQuePos[LaneID][4] = que_pos;

	}
	//防止排队长度闪烁
	que_pos1 = sort_median(pCfgs->uStatQuePos[LaneID], stat_num);
	//printf("[%d,%d,%d,%d,%d,%d],%d\n",pCfgs->uStatQuePos[LaneID][0],pCfgs->uStatQuePos[LaneID][1],pCfgs->uStatQuePos[LaneID][2],pCfgs->uStatQuePos[LaneID][3],pCfgs->uStatQuePos[LaneID][4],pCfgs->uStatQuePos[LaneID][5],que_pos);

	if(obj_num == 0)
	{
		que_pos1 = lane_bottom;
	}
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleQueueLength = que_pos1;//排队时最后的位置
	//计算排队区域内车辆数
	if(que_pos1 < lane_bottom)//有排队
	{
		for( i = 0; i < obj_num; i++)
		{
			if(obj_pos[i][0] > que_pos1)
				QueVehicleNum++;
		}
	}
	else
	{
		QueVehicleNum = 0;
	}
	//分布情况
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDistribution = (actual_dis > 254)? 254 : actual_dis;
	//得到车辆密度
	if(sum == 0)
	{
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity = 0;
	}
	else
	{
		pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity = (lane_bottom - lane_top - sum) * 100 /(lane_bottom - lane_top);
	}
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity = (pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity < 0)? 0 : pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity;
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity = (pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity > 100)? 100 : pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uVehicleDensity;
	//通道内排队数量
	pCfgs->ResultMsg.uResultInfo.uEachLaneData[LaneID].SpeedDetectInfo1.uQueueVehiSum = QueVehicleNum;//通道内排队数量
	//排队长度
	memcpy((void *)pParams->PreQueueImage, (void *)pParams->CurrQueueImage, pCfgs->team_width * pCfgs->team_height);
	//判断车道是否拥堵
	if(pCfgs->bDetCongestion == TRUE)
		CongestionDetect(LaneID, pCfgs, obj_pos, obj_num, m_ptend, obj_interval, IsVehStatic);
}
//帧差
/*void iSubStractImage(Uint8 *puSourceImage,Uint8 *puTargetImage, Uint32 nThreshold, Int16 nFromLine, Int16 nToLine, Int16 width, Int16 height)
{
	Int32 iRow,iCol,nCompareResult;

	for( iRow = nFromLine; iRow < nToLine; iRow++ )
	{
		for( iCol = 0; iCol < width; iCol++ )
		{
			nCompareResult =  *( puSourceImage + iCol + width * iRow )  -  *( puTargetImage + iCol + width * iRow ) ;
			if( abs(nCompareResult) < nThreshold )
				nCompareResult = 0;
			*( puTargetImage + iCol + width * iRow ) = (Uint16)abs(nCompareResult);
		}
	}
}*/
void iSubStractImage(Uint8 *puSourceImage,Uint8 *puTargetImage, Uint8 *puMaskImage, Uint32 nThreshold, Int16 laneID, Int16 width, Int16 height)
{
	Int32 iRow, iCol, nCompareResult;

	for( iRow = 0; iRow < height; iRow++ )
	{
		for( iCol = 0; iCol < width; iCol++ )
		{
			if( *(puMaskImage + iCol + width * iRow) == (laneID + 1))
			{
				nCompareResult =  *( puSourceImage + iCol + width * iRow )  -  *( puTargetImage + iCol + width * iRow ) ;
				if( abs(nCompareResult) < nThreshold )
					nCompareResult = 0;
				*( puTargetImage + iCol + width * iRow ) = (Uint8)abs(nCompareResult);
			}
		}
	}
}
//lhx,20150608
/*static void camera_calibration(float actual_point[][2], float img_point[][2], float mapping_matrix[], int calibration_num, ALGCFGS *pCfgs)
{
	int sub_calibration_num = 4;
	int subsection_num = (calibration_num - sub_calibration_num) / 2 + 1;
	int num = 0;
	float tx = 0, ty = 0,tu = 0, tv = 0;
	float s1 = 0, s2 = 0;
	float T1[9] = { 0 };
	float T2[9] = { 0 };
	int i, j;

	float normalization_actual_x[4];
	float normalization_actual_y[4];
	float normalization_img_x[4];
	float normalization_img_y[4];
	float A[2 * 4 * 9] = { 0 };
	float v[9 * 9] = { 0 };
	float d[9] = { 0 };
	float L[9] = { 0 };
	float T1_inv[9] = { 0 };
	float temp[9] = { 0 };
	int overlap_row1, overlap_row2, flag = 0;
	//??????
	for(num = 0; num < subsection_num; num++)
	{
		//???
		tx = ty = tu = tv = 0;
		s1 = s2 = 0;		
		for(i = 0; i < sub_calibration_num; i++)
		{
			j = i + num * 2;
			tx = tx + actual_point[j][0];
			ty = ty + actual_point[j][1];
			tu = tu + img_point[j][0];
			tv = tv + img_point[j][1];
		}
		tx = tx / sub_calibration_num;
		ty = ty / sub_calibration_num;
		tu = tu / sub_calibration_num;
		tv = tv / sub_calibration_num;
		for(i = 0; i < sub_calibration_num; i++)
		{
			j = i + num * 2;
			s1 = s1 + sqrt((img_point[j][0] - tu) * (img_point[j][0] - tu) + (img_point[j][1] - tv) * (img_point[j][1] - tv));
			s2 = s2 + sqrt((actual_point[j][0] - tx) * (actual_point[j][0] - tx) + (actual_point[j][1] - ty) * (actual_point[j][1] - ty));
		}
		s1 = (fabs(s1) < 1e-6)? 0 : sqrt(2.0) / s1;
		s2 = (fabs(s2) < 1e-6)? 0 : sqrt(2.0) / s2;
		T1[1] = T1[3] = T1[6] = T1[7] = 0;
		T1[0] = T1[4] = s1;
		T1[2] = -s1 * tu;
		T1[5] = -s1 * tv;
		T1[8] = T2[8] = 1;
		T2[1] = T2[3] = T2[6] = T2[7] = 0;
		T2[0] = T2[4] = s2;
		T2[2] = -s2 * tx;
		T2[5] = -s1 * ty;
		//?????	
		for(i = 0; i < sub_calibration_num; i++)
		{
			j = i + num * 2;
			normalization_img_x[i] = T1[0] * img_point[j][0] + T1[1] * img_point[j][1] + T1[2];
			normalization_img_y[i] = T1[3] * img_point[j][0] + T1[4] * img_point[j][1] + T1[5];
			normalization_actual_x[i] = T2[0] * actual_point[j][0] + T2[1]*actual_point[j][1] + T2[2];
			normalization_actual_y[i] = T2[3] * actual_point[j][0] + T2[4]*actual_point[j][1] + T2[5];

		}
		//????,?????

		for(i = 0; i < 2 * 4 * 9; i++)
		{
			A[i] = 0.0;
		}
		for(i = 0; i < sub_calibration_num; i++)
		{
			A[(2 * i) * 9 + 0] = normalization_actual_x[i];
			A[(2 * i) * 9 + 1] = normalization_actual_y[i];
			A[(2 * i) * 9 + 2] = 1;
			A[(2 * i) * 9 + 6] = -1 * normalization_img_x[i] * normalization_actual_x[i];
			A[(2 * i) * 9 + 7] = -1 * normalization_img_x[i] * normalization_actual_y[i];
			A[(2 * i) * 9 + 8] = -1 * normalization_img_x[i];
			A[(2 * i + 1) * 9 + 3] = normalization_actual_x[i];
			A[(2 * i + 1) * 9 + 4]=normalization_actual_y[i];
			A[(2 * i + 1) * 9 + 5] = 1;
			A[(2 * i + 1) * 9 + 6] = -1 * normalization_img_y[i] * normalization_actual_x[i];
			A[(2 * i + 1) * 9 + 7] = -1 * normalization_img_y[i] * normalization_actual_y[i];
			A[(2 * i + 1) * 9 + 8] = -1 * normalization_img_y[i];

		}
		for(i = 0; i < 9 * 9; i++)
		{
			v[i] = 0.0;
		}
		for(i = 0; i < 9;i++)
		{
			d[i] = 0.0;
		}
		//svd??
		svd( A, 2 * sub_calibration_num, 9, d, v );
		//v???????????????
		//	float L[9] = { 0 };
		for( i = 0; i < 9; i++ )
			L[i] = v[9 * i + 8];
		//???????????inv(T1)*L*T2;
		//		float T1_inv[9] = { 0 };
		for(i = 0; i < 9; i++)
		{
			T1_inv[i] = 0.0;
		}
		matrix_inverse(T1, T1_inv);

		for(i = 0; i < 9; i++)
		{
			temp[i] = 0.0;

		}


		matrix_mult(temp, T1_inv, L, 3,3,3 );
		matrix_mult(mapping_matrix, temp, T2, 3, 3, 3);
		flag = 0;
		if(num == 0)
		{
			flag = 1;
			overlap_row1 = 0;
			overlap_row2 = 0;
		}
		else
		{
			if(num == subsection_num - 1)
				flag = 2;
			overlap_row1 = (img_point[num * 2][1] + img_point[num * 2 + 1][1]) / 2;
			overlap_row2 = (img_point[num * 2 + sub_calibration_num - 4][1] + img_point[num * 2 + sub_calibration_num - 3][1]) / 2;
		}
		img_to_actual(mapping_matrix, (img_point[num * 2][1] + img_point[num * 2 + 1][1]) / 2, (img_point[num * 2 + sub_calibration_num - 2][1] + img_point[num * 2 + sub_calibration_num - 1][1]) / 2,overlap_row1, overlap_row2, flag, pCfgs);
	}

}*/
//对点进行排序
void sort_point(int array[][2], int length)
{
	int i = 0, j = 0;
	int temp[2];
	for(i = 0; i < length - 1; i++)
	{
		for(j = i + 1; j < length; j++)
		{
			if(array[i][1] > array[j][1])
			{
				temp[0] = array[i][0];
				temp[1] = array[i][1];
				array[i][0] = array[j][0];
				array[i][1] = array[j][1];
				array[j][0] = temp[0];
				array[j][1] = temp[1];
			}
		}
	}
	if(array[0][0] > array[1][0])
	{
		temp[0] = array[0][0];
		temp[1] = array[0][1];
		array[0][0] = array[1][0];
		array[0][1] = array[1][1];
		array[1][0] = temp[0];
		array[1][1] = temp[1];
	}
	if(array[2][0] > array[3][0])
	{
		temp[0] = array[2][0];
		temp[1] = array[2][1];
		array[2][0] = array[3][0];
		array[2][1] = array[3][1];
		array[3][0] = temp[0];
		array[3][1] = temp[1];
	}

}
//对相机图像进行标定
static void camera_calibration(int base_line[][2], float* base_length, int calibration_point[][2], float near_point_length, int laneNum, ALGCFGS *pCfgs, int imgW, int imgH)
{
	int i = 0, j = 0;
	//标定区域直线0——1——3——2——0
	float k01 = 0, b01 = 0;
	float k13 = 0, b13 = 0;
	float k32 = 0, b32 = 0;
	float k20 = 0, b20 = 0;
	//标定区域两条线的交点0-2 1-3
	float x0 = 0, y0 = 0;
	float dis = 1;
	//检测车道中心线斜率
	float k_road = 0, b_road = 0;
	//float k_base = 0, b_base = 0;
	float pt_x = 0, pt_y = 0, pt1_x = 0, pt1_y = 0, pt2_x = 0, pt2_y = 0, pt3_x = 0, pt3_y = 0;

	int temp, temp0 = 0;
	int start_point = 0, end_point = 0;
	float calibration_base_line[MAX_IMAGE_HEIGHT] = { 0 };
	float dis_pixel[MAX_IMAGE_HEIGHT] = { 0 };
	float temp1 = 0, temp2 = 0;
	float base_length_y = base_length[0];//垂直基准线长
	//对标定区域点进行排序
	sort_point(calibration_point, 4);
	//求标定区域直线斜率和截距
	if(calibration_point[0][0] != calibration_point[1][0])
	{
		k01 = 1.0 * (calibration_point[0][1] - calibration_point[1][1]) / (calibration_point[0][0] - calibration_point[1][0]);
		b01 = calibration_point[0][1] - k01 * calibration_point[0][0];
	}
	else
	{
		k01 = 1e+6;
	}
	if(calibration_point[1][0] != calibration_point[3][0])
	{
		k13 = 1.0 * (calibration_point[1][1] - calibration_point[3][1]) / (calibration_point[1][0] - calibration_point[3][0]);
		b13 = calibration_point[1][1] - k13 * calibration_point[1][0];
	}
	else
	{
		k13 = 1e+6;
	}
	if(calibration_point[3][0] != calibration_point[2][0])
	{
		k32 = 1.0 * (calibration_point[3][1] - calibration_point[2][1]) / (calibration_point[3][0] - calibration_point[2][0]);
		b32 = calibration_point[3][1] - k32 * calibration_point[3][0];
	}
	else
	{
		k32 = 1e+6;
	}
	if(calibration_point[2][0] != calibration_point[0][0])
	{
		k20 = 1.0 * (calibration_point[2][1] - calibration_point[0][1]) / (calibration_point[2][0] - calibration_point[0][0]);
		b20 = calibration_point[2][1] - k20 * calibration_point[2][0];
	}
	else
	{
		k20 = 1e+6;
	}
	if(base_line[0][1] > base_line[1][1])
	{
		start_point = base_line[0][1];
		end_point = base_line[1][1];
	}

	else
	{
		start_point = base_line[1][1];
		end_point = base_line[0][1];
	}
	//两条车道线是垂直线
	if(k20 > 1e+5 && k13 > 1e+5)
	{
		dis = base_length_y / (start_point - end_point + 1);
		calibration_base_line[imgH - 1] = near_point_length;
		for(i = imgH - 2; i >= 0; i--)
		{
			calibration_base_line[i] = calibration_base_line[i + 1] + dis;
			dis_pixel[i] = dis;
		}
	}
	else
	{
		if(k20 > 1e+5)
		{
			x0 = calibration_point[0][0];
			y0 = k13 * x0 + b13;
		}
		else if(k13 > 1e+5)
		{
			x0 = calibration_point[1][0];
			y0 = k20 * x0 + b20;
		}
		else
		{
			x0 = (b13 - b20) / (k20 - k13);
			y0 = k13 * x0 + b13;
		}
		//对基准线上进行标定
		temp1 = 0, temp2 = 0;
		temp1 = (float)(imgH - 1 - end_point) / (float)(end_point - y0);
		temp2 = (float)(imgH - 1 - start_point) / (float)(start_point - y0);
		dis = (float)((base_line[1][0] - base_line[0][0]) * (base_line[1][0] - base_line[0][0]));
		dis = (float)(dis + (base_line[1][1] - base_line[0][1]) * (base_line[1][1] - base_line[0][1]));
		dis = sqrt(dis);
		base_length_y = base_length_y * (float)(start_point - end_point + 1) / dis;
		dis = base_length_y / (temp1 - temp2);
		calibration_base_line[imgH - 1] = near_point_length;
		for(i = imgH - 2; i >= 0; i--)
		{
			calibration_base_line[i] = near_point_length + dis * (float)(imgH - 1 - i) / (float)(i - y0);
			dis_pixel[i] = calibration_base_line[i] - calibration_base_line[i + 1];
		}
	}
	//每个车道进行标定
	/*if(base_line[1][0] != base_line[0][0])
	{
	k_base = 1.0 * (base_line[1][1] - base_line[0][1]) / (base_line[1][0] - base_line[0][0]);
	b_base = base_line[1][1] - k_base * base_line[1][0];
	pt_x = (b01 - b_base) / (k_base - k01);
	pt_y = k01 * pt_x + b01;

	}
	else
	{
	pt_x = base_line[0][0];
	pt_y = k01 * pt_x + b01;
	}*/
	pt_x = x0;
	pt_y = k01 * pt_x + b01;
	for(i=0;i<laneNum;i++)
	{

		pt1_x = (pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0].x + pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1].x) / 2;
		pt1_y = (pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[0].y + pCfgs->DownDetectCfg.SpeedEachLane[i].MiddleCoil[1].y) / 2;
		pt2_x = (pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2].x + pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3].x) / 2;
		pt2_y = (pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[2].y + pCfgs->DownDetectCfg.SpeedEachLane[i].RearCoil[3].y) / 2;
		if(pt1_x != pt2_x)
		{
			k_road = 1.0 * (pt1_y - pt2_y) / (pt1_x - pt2_x);
			b_road = pt1_y - k_road * pt1_x;
			//求交点
			pt3_x = (b01-b_road) / (k_road - k01);
			pt3_y = k01 * pt3_x + b01;
		}
		else
		{
			//求交点
			pt3_x = pt1_x;
			pt3_y = k01 * pt3_x + b01;
		}
		temp = (int)(pt3_y + 0.5);
		temp = MAX(0, temp);
		temp = MIN(temp, imgH - 1);
		temp0 = MAX(0, (int)(pt_y + 0.5));
		temp0 = MIN(temp0, imgH - 1);
		pCfgs->actual_distance[i][temp] = calibration_base_line[temp0];
		for(j = temp + 1; j < imgH; j++)
		{
			pCfgs->actual_distance[i][j] = pCfgs->actual_distance[i][j - 1] - dis_pixel[j - 1];
		}
		for(j = temp - 1; j >= 0; j--)
		{
			pCfgs->actual_distance[i][j] = pCfgs->actual_distance[i][j + 1] + dis_pixel[j];
		}
	}
	for(j = 0; j < imgH; j++)
	{
		pCfgs->actual_degree_length[j] = pCfgs->actual_distance[laneNum - 1][j];
	}
	//对整个图像区域进行标定
	for(i = 0; i < imgW; i++)
	{
		if(k01 > 1e+5)//垂直线
		{

		}
		else
		{
			pt3_y = k01 * i + b01;
		}
		temp = (int)(pt3_y + 0.5);
		temp = MAX(0, temp);
		temp = MIN(temp, imgH - 1);
		temp0 = MAX(0, (int)(pt_y + 0.5));
		temp0 = MIN(temp0, imgH - 1);
		pCfgs->image_actual[temp][i][1] = calibration_base_line[temp0];
		for(j = temp + 1; j < imgH; j++)
		{
			pCfgs->image_actual[j][i][1] = pCfgs->image_actual[j - 1][i][1] - dis_pixel[j - 1];
		}
		for(j = temp - 1; j >= 0; j--)
		{
			pCfgs->image_actual[j][i][1] = pCfgs->image_actual[j + 1][i][1] + dis_pixel[j];
		}
	}

	//对x方向上进行标定
	float base_length_x = base_length[1];//x方向上的基准线实际距离
	float dis_x = base_length_x;
	int center_x = 0;
	float center_dis = 0;
	//对x方向基准线上进行标定
	if(k20 > 1e+5)//垂直线
	{
		pt1_x = calibration_point[0][0];
	}
	else
	{
		pt1_x = (base_line[2][1] - b20) / (k20 + 0.0000001);
	}
	if(k13 > 1e+5)//垂直线
	{
		pt2_x = calibration_point[1][0];
	}
	else
	{
		pt2_x = (base_line[2][1] - b13) / (k13 + 0.0000001);
	}
	dis_x = base_length_x * abs(pt1_x - pt2_x) / (abs(base_line[2][0] - base_line[3][0])+ 0.0000001);//基准线上标定区域所对应的实际距离
	for(i = imgH - 1; i >= 0; i--)
	{
		if(k20 > 1e+5)//垂直线
		{
			pt1_x = calibration_point[0][0];
		}
		else
		{
			pt1_x = (i - b20) / (k20 + 0.0000001);
		}
		if(k13 > 1e+5)//垂直线
		{
			pt2_x = calibration_point[1][0];
		}
		else
		{
			pt2_x = (i - b13) / (k13 + 0.0000001);
		}
		dis = dis_x / (abs(pt1_x - pt2_x) + 0.0000001);//每个像素点代表的实际距离
		center_x = (int)(pt1_x + pt2_x) / 2;//标定区域中心x值
		if(i == (imgH - 1))//图像最下端
		{
			pCfgs->image_actual[i][imgW - 1][0] = 0;
			for(j = imgW - 2; j >= 0; j--)
			{
				pCfgs->image_actual[i][j][0] = pCfgs->image_actual[i][j + 1][0] + dis;
			}
			center_dis = pCfgs->image_actual[i][center_x][0];//中心点x的距离
		}
		else//图像其他行
		{
			pCfgs->image_actual[i][center_x][0] = center_dis;//中心点x的距离
			for(j = center_x + 1; j < imgW; j++)
			{
				pCfgs->image_actual[i][j][0] = pCfgs->image_actual[i][j - 1][0] - dis;
			}
			for(j = center_x - 1; j >= 0; j--)
			{
				pCfgs->image_actual[i][j][0] = pCfgs->image_actual[i][j + 1][0] + dis;
			}
		}

	}
}
///////////////////////////////////////////////
float fuzzy(unsigned char* puNewImage, int nWidth, int nHight)//计算视频对比度
{
	float degree = 0.0;
	int i, j;
	unsigned char x1, x2, x3;
	float temp = 0.0;
	int count = 0;
	for(i = 100; i < nHight - 100;i += 4)  
	{  
		for(j = 0; j < nWidth; j += 4)  
		{  
			x1 = *(puNewImage + i * nWidth + j);
			x2 = *(puNewImage + (i + 1) * nWidth + j);
			x3 = *(puNewImage + i * nWidth + j + 1);
			degree = (x2 - x1) * (x2 - x1) + (x3 - x1) * (x3 - x1);
			temp += sqrt(degree);
			temp += abs(x2 - x1) + abs(x3 - x1);
			count++;
		}  
	}  
	degree = temp / count;
	return degree;
}

//计算视频图像颜色异常
bool Color_deviate(unsigned char* uImage, unsigned char* vImage, int width, int height)
{	
	float ave_a = 0, ave_b = 0, std_a = 0, std_b = 0;
	int x = 0, y = 0;
	float color_deviate = 0;
	int pixelnum = 0;
	int temp_a, temp_b;
	//pixelnum = width * height;
	for (y = 100; y < height - 100; y += 4)
	{
		for (x = 0; x < width; x += 4)
		{
			ave_a += *(uImage + y * width + x) - 128;
			ave_b += *(vImage + y * width + x) - 128;
			pixelnum++;
		}
	} 
	ave_a /= pixelnum;
	ave_b /= pixelnum;


	for (y = 100; y < height - 100; y += 4)
	{
		for (x = 0; x < width; x += 4)
		{
			temp_a = *(uImage + y * width + x) - 128;
			std_a += (temp_a - ave_a) * (temp_a - ave_a);
			temp_b = *(vImage + y * width + x) - 128;
			std_b += (temp_b - ave_b) * (temp_b - ave_b);
		}
	}
	std_a /= pixelnum;
	std_b /= pixelnum;
	color_deviate = sqrt(ave_a * ave_a + ave_b * ave_b) / sqrt(std_a + std_b);
	//printf("\ncolor deviate is:%f\n,",color_deviate*10);

	if (color_deviate >= 5 || color_deviate < 0.05)
	{
		return TRUE;

	} 
	else
	{
		return FALSE; 
	}

}
//统计能见度
bool visible_judge(Uint16 *a, int visib_length, int threshold)
{
	int i = 0, num = 0;
	for (i = 0; i < visib_length; i++)
	{
		if (a[i] < threshold)
		{
			num++;
		}
		else
		{
			break;
		}

	}
	//当能见度大于数组长度一半以上，才认为是能见度高
	if (num > (visib_length / 2))
	{
		return TRUE;
	} 
	else
	{
		return FALSE;
	}
}